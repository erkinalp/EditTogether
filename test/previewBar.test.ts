import PreviewBar, { PreviewBarSegment } from '../src/js-components/previewBar';
import { ActionType, Category, CategorySkipOption, SegmentContainer, SponsorSourceType } from '../src/types';

// Mock Config
const mockConfig = {
    config: {
        modifyTimelineAsIfSegmentsWerentThere: false,
        // Add other config properties PreviewBar might access directly, if any
        // For now, assuming only this one is directly accessed by the relevant logic
        barTypes: {}, // Used in createBar for opacity, provide a default
        renderSegmentsAsChapters: false, // Used in chapterFilter
        showAutogeneratedChapters: true, // Used in chapterFilter
    },
};

// Mock getComputedStyle which might be used internally by some DOM manipulations or checks
global.getComputedStyle = jest.fn(() => ({
    marginRight: '0px',
    // Add any other style properties that might be accessed
}));

// Mock for parent element and other DOM requirements if PreviewBar constructor needs them
// The 'test = true' flag in PreviewBar constructor should minimize DOM needs.
const mockParent = {} as HTMLElement; 
const mockChapterVote = {} as any; // Replace 'any' with ChapterVote mock if needed
const mockUpdateExistingChapters = jest.fn();


const EPSILON = 0.00001; // For float comparisons

// Helper to create segments
const createSegment = (start: number, end: number, category: Category, actionType: ActionType, source: SponsorSourceType = SponsorSourceType.Server): PreviewBarSegment => ({
    segment: [start, end],
    category,
    actionType,
    unsubmitted: false,
    showLarger: false,
    description: '',
    source,
});

describe('PreviewBar', () => {
    let previewBar: PreviewBar;
    let mockGetCategorySkipOption: jest.Mock;

    beforeEach(() => {
        // Reset mocks and config before each test
        mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false;
        mockGetCategorySkipOption = jest.fn();
        
        // Mocking the global Config object that PreviewBar might import and use
        // This is a simplified approach. In a real Jest setup, you might use jest.mock
        global.Config = mockConfig as any;

        previewBar = new PreviewBar(
            mockParent,
            false, // onMobileYouTube
            false, // onInvidious
            false, // onYTTV
            mockChapterVote,
            mockUpdateExistingChapters,
            mockGetCategorySkipOption,
            true // test = true (to bypass DOM initialization)
        );
    });

    describe('Feature Disabled: modifyTimelineAsIfSegmentsWerentThere = false', () => {
        beforeEach(() => {
            mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false;
        });

        it('virtualVideoDuration should equal videoDuration', () => {
            previewBar.set([], 100);
            expect(previewBar.virtualVideoDuration).toBe(100);
        });

        it('timeToDecimal should be linear to videoDuration', () => {
            previewBar.set([], 100);
            expect(previewBar.timeToDecimal(0)).toBeCloseTo(0, EPSILON);
            expect(previewBar.timeToDecimal(50)).toBeCloseTo(0.5, EPSILON);
            expect(previewBar.timeToDecimal(100)).toBeCloseTo(1, EPSILON);
        });

        it('decimalToTime should be linear to videoDuration', () => {
            previewBar.set([], 100);
            expect(previewBar.decimalToTime(0)).toBeCloseTo(0, EPSILON);
            expect(previewBar.decimalToTime(0.5)).toBeCloseTo(50, EPSILON);
            expect(previewBar.decimalToTime(1)).toBeCloseTo(100, EPSILON);
        });

        it('segment bar calculations should use videoDuration', () => {
            const segment = createSegment(10, 30, 'sponsor' as Category, ActionType.Skip);
            previewBar.set([segment], 100);
            // createBar is complex to test directly without more DOM mocks,
            // but its core logic relies on timeToPercentage and timeToRightPercentage,
            // which use timeToDecimal. We've tested timeToDecimal.
            // We can infer that if timeToDecimal is correct, createBar will be too.
            // For a deeper test, one would need to mock bar.style and assert percentages.
            // Example:
            // const barElement = previewBar.createBar(segment);
            // expect(barElement.style.left).toBe("10%"); 
            // expect(barElement.style.right).toBe("70%"); 
            expect(previewBar.timeToPercentage(10)).toBe("10%");
            expect(previewBar.timeToRightPercentage(30)).toBe("70%");
        });
    });

    describe('Feature Enabled, No Skippable Segments', () => {
        beforeEach(() => {
            mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
            // No segment is AutoSkip
            mockGetCategorySkipOption.mockReturnValue(CategorySkipOption.ManualSkip);
        });

        it('virtualVideoDuration should equal videoDuration', () => {
            const segments = [createSegment(10, 20, 'sponsor' as Category, ActionType.Skip)];
            previewBar.set(segments, 100);
            expect(previewBar.virtualVideoDuration).toBe(100);
        });

        it('time conversions should be like feature disabled', () => {
            previewBar.set([], 100);
            expect(previewBar.timeToDecimal(50)).toBeCloseTo(0.5, EPSILON);
            expect(previewBar.decimalToTime(0.5)).toBeCloseTo(50, EPSILON);
        });
    });

    describe('Feature Enabled, One Skippable Segment (ActionType.Skip, AutoSkip)', () => {
        const videoDuration = 100;
        const skippableCategory = 'sponsor' as Category;
        
        beforeEach(() => {
            mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
            mockGetCategorySkipOption.mockImplementation((category: Category) => {
                if (category === skippableCategory) {
                    return CategorySkipOption.AutoSkip;
                }
                return CategorySkipOption.ManualSkip;
            });
        });

        // Test cases for segment at beginning, middle, end
        const testCases = [
            { name: 'at the beginning', segment: createSegment(0, 20, skippableCategory, ActionType.Skip), nonSkippableTimeBefore: -1, nonSkippableTimeIn: 10, nonSkippableTimeAfter: 30, virtualClickBefore: -1, virtualClickInSkipped: 0.05, actualTimeForVirtualClickInSkipped: 20, virtualClickAfter: 0.125, actualTimeForVirtualClickAfter: 30},
            { name: 'in the middle', segment: createSegment(40, 60, skippableCategory, ActionType.Skip), nonSkippableTimeBefore: 30, nonSkippableTimeIn: 50, nonSkippableTimeAfter: 70, virtualClickBefore: 0.25, actualTimeForVirtualClickBefore: 20, virtualClickInSkipped: 0.5, actualTimeForVirtualClickInSkipped: 60, virtualClickAfter: 0.625, actualTimeForVirtualClickAfter: 70 },
            { name: 'at the end', segment: createSegment(80, 100, skippableCategory, ActionType.Skip), nonSkippableTimeBefore: 70, nonSkippableTimeIn:90, nonSkippableTimeAfter: -1, virtualClickBefore: 0.875, actualTimeForVirtualClickBefore: 70, virtualClickInSkipped: 0.95, actualTimeForVirtualClickInSkipped: 100, virtualClickAfter: -1 }
        ];

        testCases.forEach(tc => {
            describe(`Skippable segment ${tc.name}`, () => {
                beforeEach(() => {
                    previewBar.set([tc.segment], videoDuration);
                });

                it('virtualVideoDuration should be reduced', () => {
                    expect(previewBar.virtualVideoDuration).toBe(videoDuration - (tc.segment.segment[1] - tc.segment.segment[0]));
                });

                it('timeToDecimal: actual times before skippable segment', () => {
                    if (tc.nonSkippableTimeBefore !== -1) {
                        // E.g. actual 30 with skip 40-60 (virtual dur 80) -> 30 / 80 = 0.375
                        const expectedDecimal = tc.nonSkippableTimeBefore / previewBar.virtualVideoDuration;
                        expect(previewBar.timeToDecimal(tc.nonSkippableTimeBefore)).toBeCloseTo(expectedDecimal, EPSILON);
                    }
                });
                
                it('timeToDecimal: actual times within skippable segment should map to virtual start of segment', () => {
                     // timeToDecimal(actualTime) for time within a skippable segment should give the decimal of the virtual start of that segment
                    let skippedDurationBeforeSegment = 0;
                    if (tc.segment.segment[0] > 0) { // if segment is not at the start
                         // This needs to be more robust if there are multiple segments before
                         // For a single segment tc.segment.segment[0] is the time before it that is not skipped
                         // if tc.segment is at 40-60, then 0-40 is not skipped (40 duration)
                         // if tc.segment is at 0-20, then this is 0.
                         // This is actually the virtual time of the start of the segment.
                         skippedDurationBeforeSegment = tc.segment.segment[0]; // this is the actual time before the segment
                    }
                    // The virtual time of the skippable segment's start point
                    const virtualTimeOfSegmentStart = tc.segment.segment[0] - 0; // Assuming no prior skips for single segment test
                    const expectedDecimalForStart = virtualTimeOfSegmentStart / previewBar.virtualVideoDuration;
                    expect(previewBar.timeToDecimal(tc.nonSkippableTimeIn)).toBeCloseTo(expectedDecimalForStart, EPSILON);
                });

                it('timeToDecimal: actual times after skippable segment', () => {
                    if (tc.nonSkippableTimeAfter !== -1) {
                        // E.g. actual 70 with skip 40-60 (virtual dur 80, skip dur 20) -> (70 - 20) / 80 = 50 / 80 = 0.625
                        const segmentDuration = tc.segment.segment[1] - tc.segment.segment[0];
                        const expectedDecimal = (tc.nonSkippableTimeAfter - segmentDuration) / previewBar.virtualVideoDuration;
                        expect(previewBar.timeToDecimal(tc.nonSkippableTimeAfter)).toBeCloseTo(expectedDecimal, EPSILON);
                    }
                });

                it('decimalToTime: virtual decimal before skippable segment', () => {
                    if (tc.virtualClickBefore !== -1) {
                        expect(previewBar.decimalToTime(tc.virtualClickBefore)).toBeCloseTo(tc.actualTimeForVirtualClickBefore, EPSILON);
                    }
                });
                
                it('decimalToTime: virtual decimal within the (now virtualized) skippable segment span maps to actual time at end of real segment', () => {
                    // A click on the virtual timeline where the segment *would have been* should effectively jump to the content *after* the segment.
                    // The current decimalToTime implementation maps any virtual time within the "eaten up" space to the actual start of the *next* visible content.
                    // So, if segment is 40-60, virtual duration 80. Virtual 0.5 corresponds to actual 40.
                    // A click at virtual 0.5 (which is where the non-skippable content before the segment ends)
                    // should result in actual time 60 (start of content after the skip).
                    const virtualTimeOfSegmentStart = tc.segment.segment[0] / previewBar.virtualVideoDuration; // if segment is 40-60, this is 40/80 = 0.5
                    // tc.actualTimeForVirtualClickInSkipped is the actual time this virtual click should map to.
                    // For a click within the "space" of a skipped segment, it should resolve to the end of that segment.
                    expect(previewBar.decimalToTime(virtualTimeOfSegmentStart)).toBeCloseTo(tc.segment.segment[1], EPSILON);
                    if (tc.virtualClickInSkipped !== -1 && tc.virtualClickInSkipped > virtualTimeOfSegmentStart) {
                         // If we click slightly past the virtual start, it should still resolve to the end of the actual skipped part.
                         expect(previewBar.decimalToTime(tc.virtualClickInSkipped)).toBeCloseTo(tc.segment.segment[1], EPSILON);
                    }
                });

                it('decimalToTime: virtual decimal after skippable segment', () => {
                    if (tc.virtualClickAfter !== -1) {
                        expect(previewBar.decimalToTime(tc.virtualClickAfter)).toBeCloseTo(tc.actualTimeForVirtualClickAfter, EPSILON);
                    }
                });
                
                it('skippable segment bar should have zero width', () => {
                    // This test relies on the createBar logic for setting left/right
                    // For a skippable segment, left and right should make it zero width effectively
                    // timeToPercentage(actualStartTime) and timeToRightPercentage(actualStartTime)
                    const barElement = previewBar.createBar(tc.segment);
                    const expectedLeft = previewBar.timeToPercentage(tc.segment.segment[0]);
                    const expectedRight = previewBar.timeToRightPercentage(tc.segment.segment[0]);
                    expect(barElement.style.left).toBe(expectedLeft);
                    expect(barElement.style.right).toBe(expectedRight);

                    // Also verify via intervalToDecimal for the segment itself
                    expect(previewBar.intervalToDecimal(tc.segment.segment[0], tc.segment.segment[1])).toBeCloseTo(0, EPSILON);
                });
            });
        });
    });
    
    describe('Feature Enabled, Multiple Skippable Segments', () => {
        const videoDuration = 100;
        const skippableCategory = 'sponsor' as Category;
        const segment1 = createSegment(10, 20, skippableCategory, ActionType.Skip); // 10s
        const segment2 = createSegment(50, 70, skippableCategory, ActionType.Skip); // 20s
        // Total skip = 30s. Virtual duration = 70s.

        beforeEach(() => {
            mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
            mockGetCategorySkipOption.mockImplementation((category: Category) => {
                if (category === skippableCategory) return CategorySkipOption.AutoSkip;
                return CategorySkipOption.ManualSkip;
            });
            previewBar.set([segment1, segment2], videoDuration);
        });

        it('virtualVideoDuration should be correctly reduced', () => {
            expect(previewBar.virtualVideoDuration).toBe(videoDuration - (10 + 20));
        });

        // Actual Time -> Virtual Decimal
        it('timeToDecimal: actual time before any skips', () => {
            // Actual 5 -> Virtual 5. 5 / 70
            expect(previewBar.timeToDecimal(5)).toBeCloseTo(5 / 70, EPSILON);
        });
        it('timeToDecimal: actual time after first skip, before second', () => {
            // Actual 30 (is 10s into content after 1st skip). Virtual time = 30 - 10 = 20. 20 / 70
            expect(previewBar.timeToDecimal(30)).toBeCloseTo(20 / 70, EPSILON);
        });
        it('timeToDecimal: actual time within second skip maps to its virtual start', () => {
            // Actual 60 (within 50-70 skip). Virtual start of this segment is (50 - 10) = 40. 40 / 70
            expect(previewBar.timeToDecimal(60)).toBeCloseTo((50 - 10) / 70, EPSILON);
        });
        it('timeToDecimal: actual time after all skips', () => {
            // Actual 80. Virtual time = 80 - (10+20) = 50. 50 / 70
            expect(previewBar.timeToDecimal(80)).toBeCloseTo(50 / 70, EPSILON);
        });

        // Virtual Decimal -> Actual Time
        it('decimalToTime: virtual decimal mapping to time before any skips', () => {
            // Virtual decimal 5/70 -> Actual 5
            expect(previewBar.decimalToTime(5 / 70)).toBeCloseTo(5, EPSILON);
        });
        it('decimalToTime: virtual decimal mapping to time between skips', () => {
            // Virtual decimal 20/70 -> Actual 30
            expect(previewBar.decimalToTime(20 / 70)).toBeCloseTo(30, EPSILON);
        });
         it('decimalToTime: virtual decimal mapping to time after all skips', () => {
            // Virtual decimal 50/70 -> Actual 80
            expect(previewBar.decimalToTime(50 / 70)).toBeCloseTo(80, EPSILON);
        });
        it('decimalToTime: virtual decimal at start of first skip maps to end of first skip', () => {
            // Virtual start of first skip (10-20) is (10-0)/70 = 10/70. Maps to actual 20.
            expect(previewBar.decimalToTime(10 / 70)).toBeCloseTo(20, EPSILON);
        });
        it('decimalToTime: virtual decimal at start of second skip maps to end of second skip', () => {
            // Virtual start of second skip (50-70) is (50-10)/70 = 40/70. Maps to actual 70.
            expect(previewBar.decimalToTime(40 / 70)).toBeCloseTo(70, EPSILON);
        });
    });

    describe('Feature Enabled, All Segments Skippable', () => {
        const videoDuration = 100;
        const skippableCategory = 'sponsor' as Category;
        const segment1 = createSegment(0, 50, skippableCategory, ActionType.Skip);
        const segment2 = createSegment(50, 100, skippableCategory, ActionType.Skip);

        beforeEach(() => {
            mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
            mockGetCategorySkipOption.mockReturnValue(CategorySkipOption.AutoSkip);
            previewBar.set([segment1, segment2], videoDuration);
        });

        it('virtualVideoDuration should be 0', () => {
            expect(previewBar.virtualVideoDuration).toBe(0);
        });

        it('timeToDecimal should always return 0 if virtualVideoDuration is 0', () => {
            expect(previewBar.timeToDecimal(0)).toBe(0);
            expect(previewBar.timeToDecimal(50)).toBe(0);
            expect(previewBar.timeToDecimal(100)).toBe(0);
        });

        it('decimalToTime should map to actual time proportional to original video or end of segments', () => {
            // If virtual duration is 0, any virtual decimal click effectively means clicking at virtual "0".
            // The logic should map this to the end of all skippable segments, which is videoDuration.
            expect(previewBar.decimalToTime(0)).toBeCloseTo(videoDuration, EPSILON);
            expect(previewBar.decimalToTime(0.5)).toBeCloseTo(videoDuration, EPSILON);
            expect(previewBar.decimalToTime(1)).toBeCloseTo(videoDuration, EPSILON);
        });
    });

    describe('Segments of Type Mute (should not alter timeline length)', () => {
        const videoDuration = 100;
        const muteCategory = 'music_offtopic' as Category;
        const muteSegment = createSegment(30, 70, muteCategory, ActionType.Mute);

        beforeEach(() => {
            mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
            // Even if category is AutoSkip, Mute type should prevent timeline modification
            mockGetCategorySkipOption.mockReturnValue(CategorySkipOption.AutoSkip); 
            previewBar.set([muteSegment], videoDuration);
        });

        it('virtualVideoDuration should equal videoDuration', () => {
            expect(previewBar.virtualVideoDuration).toBe(videoDuration);
        });

        it('timeToDecimal for Mute segment acts as if not skippable for timeline change', () => {
            expect(previewBar.timeToDecimal(50)).toBeCloseTo(0.5, EPSILON);
        });
        
        it('createBar for Mute segment should render normally (not zero-width)', () => {
            const barElement = previewBar.createBar(muteSegment);
            // Expected: left=30%, right=(100-70)% = 30%
            expect(barElement.style.left).toBe(previewBar.timeToPercentage(30));
            expect(barElement.style.right).toBe(previewBar.timeToRightPercentage(70));
            // Interval should be its actual length / videoDuration
            expect(previewBar.intervalToDecimal(30,70)).toBeCloseTo((70-30)/videoDuration, EPSILON);
        });
    });
    
    describe('Segments of Type POI or Full (should not alter timeline length)', () => {
        const videoDuration = 100;
        const poiSegment = createSegment(10, 20, 'poi_highlight' as Category, ActionType.Poi);
        const fullSegment = createSegment(0, 100, 'sponsor' as Category, ActionType.Full);

        beforeEach(() => {
            mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
            mockGetCategorySkipOption.mockReturnValue(CategorySkipOption.AutoSkip); // Category set to autoskip
            previewBar.set([poiSegment, fullSegment], videoDuration);
        });

        it('virtualVideoDuration should equal videoDuration for POI and Full', () => {
            expect(previewBar.virtualVideoDuration).toBe(videoDuration);
        });
         it('createBar for POI/Full segments should render normally', () => {
            const barPOI = previewBar.createBar(poiSegment);
            expect(barPOI.style.left).toBe(previewBar.timeToPercentage(10));
            expect(barPOI.style.right).toBe(previewBar.timeToRightPercentage(20));

            const barFull = previewBar.createBar(fullSegment);
            expect(barFull.style.left).toBe(previewBar.timeToPercentage(0));
            expect(barFull.style.right).toBe(previewBar.timeToRightPercentage(100));
        });
    });
});

// Minimal mock for global Config if not using jest.mock for imports
if (typeof global.Config === 'undefined') {
    global.Config = mockConfig as any;
}
if (typeof global.chrome === 'undefined') {
    global.chrome = { runtime: { id: 'test-id' } } as any;
}
