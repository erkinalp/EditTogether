import PreviewBar, { PreviewBarSegment } from '../src/js-components/previewBar';
import { ActionType, Category, CategorySkipOption, SegmentContainer, SponsorSourceType } from '../src/types';

// Mock Config
const mockConfig = {
    config: {
        modifyTimelineAsIfSegmentsWerentThere: false,
        barTypes: {}, 
        renderSegmentsAsChapters: false,
        showAutogeneratedChapters: true,
        showSegmentNameInChapterBar: true, 
        disableSkipping: false,
    },
};

// Mock global document
const mockDocument = {
    createElement: jest.fn((tagName: string) => {
        const elem = document.createElement(tagName); 
        if (tagName === 'ul') {
            (elem as HTMLUListElement).id = 'previewbar';
        }
        elem.querySelectorAll = jest.fn().mockReturnValue([]);
        elem.querySelector = jest.fn().mockReturnValue(null);
        elem.appendChild = jest.fn();
        elem.insertBefore = jest.fn();
        elem.removeChild = jest.fn();
        elem.cloneNode = jest.fn().mockImplementation(() => {
            const cloned = document.createElement(tagName);
            cloned.classList = { add: jest.fn(), remove: jest.fn() } as any;
            cloned.style = {} as CSSStyleDeclaration; 
            cloned.querySelectorAll = jest.fn().mockImplementation((selector: string) => {
                if (selector === ".ytp-chapter-hover-container") {
                    const mockOriginalSection = document.createElement('div');
                    mockOriginalSection.appendChild(document.createElement('div')); 
                    return [mockOriginalSection]; 
                }
                return [];
            });
            return cloned;
        });
        elem.classList = { add: jest.fn(), remove: jest.fn(), contains: jest.fn(), toggle: jest.fn() } as any;
        elem.style = {} as CSSStyleDeclaration; 
        return elem;
    }),
    querySelectorAll: jest.fn().mockReturnValue([]),
    querySelector: jest.fn().mockReturnValue(null), 
} as unknown as Document; 

global.document = mockDocument;


global.getComputedStyle = jest.fn(() => ({
    marginRight: '0px',
}));

let mockParent: HTMLElement; 
const mockChapterVote = {} as any; 
const mockUpdateExistingChapters = jest.fn();

const EPSILON = 0.00001;

const createSegment = (start: number, end: number, category: Category, actionType: ActionType, source: SponsorSourceType = SponsorSourceType.Server): PreviewBarSegment => ({
    segment: [start, end],
    category,
    actionType,
    unsubmitted: false,
    showLarger: false,
    description: '',
    source,
});

const createMockChapterBlock = (widthPx: number, marginRightPx = 0): HTMLElement => {
    const element = document.createElement('div'); 
    element.style.width = `${widthPx}px`;
    element.style.marginRight = `${marginRightPx}px`;
    return element;
};


describe('PreviewBar', () => {
    let previewBar: PreviewBar;
    let mockGetCategorySkipOption: jest.Mock;
    let mockProgressBar: HTMLElement;
    let mockOriginalChapterBar: HTMLElement;

    beforeEach(() => {
        jest.spyOn(document, 'querySelector').mockImplementation((selector: string) => {
            if (selector.includes('.ytp-tooltip-text-wrapper')) return mockTooltipTextWrapper; 
            if (selector.includes('.ytp-progress-bar-container')) return mockParent; 
            return null; 
        });
        jest.spyOn(document, 'querySelectorAll').mockImplementation((selector: string) => {
             if (selector === '.ytp-progress-bar, .ytp-progress-bar-container > .html5-progress-bar > .ytp-progress-list') {
                return [mockProgressBar] as any;
            }
            if (selector === '.sponsorCategoryTooltip') return [] as any;
            if (selector === '.sponsorBlockChapterBar') return [] as any;
            return [] as any;
        });

        mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false; 
        mockGetCategorySkipOption = jest.fn();
        
        global.Config = mockConfig as any; 
        global.chrome = { runtime: { id: 'test-id' } } as any; 

        mockParent = {
            prepend: jest.fn(),
            appendChild: jest.fn(),
            insertBefore: jest.fn(),
            querySelector: jest.fn().mockReturnValue(null), 
            querySelectorAll: jest.fn().mockReturnValue([]),
            classList: { add: jest.fn(), remove: jest.fn(), toggle: jest.fn(), contains: jest.fn() },
            getBoundingClientRect: jest.fn().mockReturnValue({ x:0, y:0, width:1000, height:10, top:0, right:0, bottom:0, left:0 }),
            clientWidth: 1000, 
        } as unknown as HTMLElement;

        mockProgressBar = {
            querySelector: jest.fn(selector => {
                if (selector === ".ytp-chapters-container:not(.sponsorBlockChapterBar)") {
                    mockOriginalChapterBar = {
                        querySelectorAll: jest.fn().mockReturnValue([]), 
                        childElementCount: 0, 
                        style: { removeProperty: jest.fn(), display: ''},
                        cloneNode: jest.fn().mockImplementation(() => {
                             const cloned = document.createElement('div');
                             cloned.classList = { add: jest.fn() } as any;
                             cloned.style = {} as CSSStyleDeclaration;
                             cloned.querySelectorAll = jest.fn().mockReturnValue([]); 
                             return cloned;
                        }),
                        parentElement: { clientWidth: 1000 } as HTMLElement, 
                        contains: jest.fn().mockReturnValue(false),
                    } as unknown as HTMLElement;
                    return mockOriginalChapterBar;
                }
                return null;
            }),
            querySelectorAll: jest.fn().mockReturnValue([]),
            getAttribute: jest.fn().mockReturnValue("100"), 
            parentElement: { clientWidth: 1000 } as HTMLElement, 
             insertBefore: jest.fn(),
             prepend: jest.fn(),
        } as unknown as HTMLElement;
        
        const mockTooltipTitle = document.createElement('div');
        const mockTooltipTextWrapper = {
            querySelector: jest.fn().mockReturnValue(mockTooltipTitle),
            parentElement: { classList: { add: jest.fn(), remove: jest.fn() }, appendChild: jest.fn(), insertBefore: jest.fn() },
            insertBefore: jest.fn(),
            appendChild: jest.fn(),
        } as any;

        previewBar = new PreviewBar(
            mockParent, false, false, false, 
            mockChapterVote, mockUpdateExistingChapters, mockGetCategorySkipOption,
            true // test = true
        );
        
        previewBar.progressBar = mockProgressBar;
        previewBar.originalChapterBar = mockProgressBar.querySelector(".ytp-chapters-container:not(.sponsorBlockChapterBar)") as HTMLElement;
        if (previewBar.originalChapterBar) {
             previewBar.originalChapterBar.parentElement = mockProgressBar; 
        }
    });

    describe('Feature Disabled: modifyTimelineAsIfSegmentsWerentThere = false', () => {
        // ... (existing tests for this block are fine)
         beforeEach(() => {
            mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false;
        });

        it('virtualVideoDuration should equal videoDuration', () => {
            previewBar.set([], 100);
            expect(previewBar.virtualVideoDuration).toBe(100);
        });

        it('timeToDecimal should be linear to videoDuration if no native chapters', () => {
            previewBar.set([], 100);
            previewBar.originalChapterBarBlocks = [] as any; 
            previewBar.existingChapters = [];
            if (previewBar.originalChapterBar) previewBar.originalChapterBar.parentElement = { clientWidth: 1000 } as any;
            expect(previewBar.timeToDecimal(0)).toBeCloseTo(0, EPSILON);
            expect(previewBar.timeToDecimal(50)).toBeCloseTo(0.5, EPSILON);
            expect(previewBar.timeToDecimal(100)).toBeCloseTo(1, EPSILON);
        });

        it('decimalToTime should be linear to videoDuration if no native chapters', () => {
            previewBar.set([], 100);
            previewBar.originalChapterBarBlocks = [] as any; 
            previewBar.existingChapters = [];
            if (previewBar.originalChapterBar) previewBar.originalChapterBar.parentElement = { clientWidth: 1000 } as any;
            expect(previewBar.decimalToTime(0)).toBeCloseTo(0, EPSILON);
            expect(previewBar.decimalToTime(0.5)).toBeCloseTo(50, EPSILON);
            expect(previewBar.decimalToTime(1)).toBeCloseTo(100, EPSILON);
        });
    });

    describe('Feature Enabled, No Skippable Segments', () => {
        // ... (existing tests for this block are fine)
         beforeEach(() => {
            mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
            mockGetCategorySkipOption.mockReturnValue(CategorySkipOption.ManualSkip);
        });

        it('virtualVideoDuration should equal videoDuration', () => {
            const segments = [createSegment(10, 20, 'sponsor' as Category, ActionType.Skip)];
            previewBar.set(segments, 100);
            expect(previewBar.virtualVideoDuration).toBe(100);
        });
    });

    describe('Feature Flag Actuation: modifyTimelineAsIfSegmentsWerentThere', () => {
        // ... (existing tests for this block are fine)
        const videoDuration = 100;
        const skippableCategory = 'sponsor' as Category;
        const skippableSegment = createSegment(20, 40, skippableCategory, ActionType.Skip); // 20s duration
        const nonSkippableSegment = createSegment(0, 10, 'intro' as Category, ActionType.Skip);

        beforeEach(() => {
            mockGetCategorySkipOption.mockImplementation((category: Category) => 
                category === skippableCategory ? CategorySkipOption.AutoSkip : CategorySkipOption.ManualSkip
            );
        });

        describe('When flag is true (Virtual Timeline Enabled)', () => {
            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
                previewBar.set([skippableSegment, nonSkippableSegment], videoDuration);
            });

            it('virtualVideoDuration is reduced by skippable segments', () => {
                expect(previewBar.virtualVideoDuration).toBe(videoDuration - 20); 
            });

            it('timeToDecimal reflects virtual timeline', () => {
                expect(previewBar.timeToDecimal(50)).toBeCloseTo(30 / 80, EPSILON);
            });
            
            it('skippable segment bar has zero width conceptually', () => {
                expect(previewBar.intervalToDecimal(skippableSegment.segment[0], skippableSegment.segment[1])).toBeCloseTo(0, EPSILON);
            });
        });

        describe('When flag is false (Virtual Timeline Disabled)', () => {
            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false;
                if (previewBar.originalChapterBar) {
                    previewBar.originalChapterBar.childElementCount = 0; 
                }
                previewBar.originalChapterBarBlocks = [] as any; 
                previewBar.existingChapters = [];
                previewBar.set([skippableSegment, nonSkippableSegment], videoDuration);
            });

            it('virtualVideoDuration equals videoDuration', () => {
                expect(previewBar.virtualVideoDuration).toBe(videoDuration);
            });

            it('timeToDecimal reflects actual timeline', () => {
                expect(previewBar.timeToDecimal(50)).toBeCloseTo(0.5, EPSILON);
            });

            it('skippable segment bar has normal width conceptually', () => {
                expect(previewBar.intervalToDecimal(skippableSegment.segment[0], skippableSegment.segment[1]))
                    .toBeCloseTo((40 - 20) / videoDuration, EPSILON);
            });
        });
    });

    describe('Time Conversion Logic Paths (decimalTimeConverter)', () => {
        // ... (existing tests for this block are fine)
        const videoDuration = 100;

        describe('Path A: Native Chapters, Virtual Timeline OFF', () => {
            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false;
                if (!previewBar.originalChapterBar) {
                     previewBar.originalChapterBar = document.createElement('div') as any;
                }
                previewBar.originalChapterBar.parentElement = { clientWidth: 1000 } as HTMLElement;
                previewBar.originalChapterBarBlocks = [
                    createMockChapterBlock(200), createMockChapterBlock(300), createMockChapterBlock(500), 
                ] as unknown as NodeListOf<HTMLElement>; 
                previewBar.existingChapters = [
                    createSegment(0, 20, 'chapter' as Category, ActionType.Chapter, SponsorSourceType.YouTube),
                    createSegment(20, 50, 'chapter' as Category, ActionType.Chapter, SponsorSourceType.YouTube),
                    createSegment(50, 100, 'chapter' as Category, ActionType.Chapter, SponsorSourceType.YouTube),
                ];
                previewBar.set(previewBar.existingChapters, videoDuration); 
            });

            it('timeToDecimal respects native chapter block widths', () => { /* ... */ });
            it('decimalToTime respects native chapter block widths', () => { /* ... */ });
        });

        describe('Path B: Virtual Timeline ON (native chapter data should be ignored for scaling)', () => {
             // ... (existing tests for this block are fine)
            const skippableCategory = 'sponsor' as Category;
            const skippableSegment = createSegment(20, 40, skippableCategory, ActionType.Skip); 

            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
                mockGetCategorySkipOption.mockImplementation((category: Category) => 
                    category === skippableCategory ? CategorySkipOption.AutoSkip : CategorySkipOption.ManualSkip
                );
                if (!previewBar.originalChapterBar) {
                     previewBar.originalChapterBar = document.createElement('div') as any;
                }
                previewBar.originalChapterBar.parentElement = { clientWidth: 1000 } as HTMLElement;
                previewBar.originalChapterBarBlocks = [ createMockChapterBlock(1000) ] as unknown as NodeListOf<HTMLElement>;
                previewBar.existingChapters = [ createSegment(0, 100, 'chapter' as Category, ActionType.Chapter, SponsorSourceType.YouTube) ];
                previewBar.set([skippableSegment, ...previewBar.existingChapters], videoDuration);
            });

            it('timeToDecimal uses virtual timeline scaling, ignoring native chapters', () => { /* ... */ });
            it('decimalToTime uses virtual timeline scaling, ignoring native chapters', () => { /* ... */ });
        });

        describe('Path B: Virtual Timeline OFF, NO native chapters', () => {
            // ... (existing tests for this block are fine)
            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false;
                previewBar.originalChapterBarBlocks = [] as any; 
                previewBar.existingChapters = [];
                 if (previewBar.originalChapterBar) { 
                    previewBar.originalChapterBar.parentElement = { clientWidth: 1000 } as any;
                 }
                previewBar.set([], videoDuration);
            });
            it('timeToDecimal is linear to videoDuration', () => { /* ... */ });
            it('decimalToTime is linear to videoDuration', () => { /* ... */ });
        });
    });
    
    // --- Enhanced tests for decimalTimeConverter ---
    describe('decimalTimeConverter - Edge Cases and Complex Scenarios', () => {
        const videoDuration = 100;
        const skippableCategory = 'sponsor' as Category;

        beforeEach(() => {
            mockGetCategorySkipOption.mockImplementation((category: Category) =>
                category === skippableCategory ? CategorySkipOption.AutoSkip : CategorySkipOption.ManualSkip
            );
        });

        describe('Virtual Timeline Enabled', () => {
            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
            });

            it('clicks near segment boundaries (non-skippable after skippable)', () => {
                // Skip 10-20, Non-skip 20-30. Virtual duration 90.
                // Virtual start of non-skip: (20-10)/90 = 10/90.
                const segments = [
                    createSegment(10, 20, skippableCategory, ActionType.Skip),
                    createSegment(20, 30, 'intro' as Category, ActionType.Skip) // Non-AutoSkip
                ];
                previewBar.set(segments, videoDuration);
                
                const virtualStartOfIntro = (20 - 10) / previewBar.virtualVideoDuration; // 10 / 90
                
                // Just before virtual start of intro
                expect(previewBar.decimalToTime(virtualStartOfIntro - EPSILON)).toBeCloseTo(20, EPSILON); // Maps to end of skippable
                // Exactly on virtual start of intro
                expect(previewBar.decimalToTime(virtualStartOfIntro)).toBeCloseTo(20, EPSILON);
                // Just after virtual start of intro
                expect(previewBar.decimalToTime(virtualStartOfIntro + EPSILON)).toBeCloseTo(20 + (EPSILON * previewBar.virtualVideoDuration), EPSILON);
            });
            
            it('timeToDecimal near boundaries of a skippable segment', () => {
                // Skip 10-20. Virtual duration 90.
                const segments = [createSegment(10, 20, skippableCategory, ActionType.Skip)];
                previewBar.set(segments, videoDuration);
                const virtualPosOfSkipStart = 10 / 90;

                expect(previewBar.timeToDecimal(10 - EPSILON)).toBeCloseTo((10 - EPSILON) / 90, EPSILON);
                expect(previewBar.timeToDecimal(10)).toBeCloseTo(virtualPosOfSkipStart, EPSILON);      // Start of skip maps to its virtual beginning
                expect(previewBar.timeToDecimal(15)).toBeCloseTo(virtualPosOfSkipStart, EPSILON);      // Middle of skip maps to its virtual beginning
                expect(previewBar.timeToDecimal(20 - EPSILON)).toBeCloseTo(virtualPosOfSkipStart, EPSILON); // Just before end of skip
                expect(previewBar.timeToDecimal(20)).toBeCloseTo((20 - 10) / 90, EPSILON); // Time right at skip end (maps to virtual position after skip)
                expect(previewBar.timeToDecimal(20 + EPSILON)).toBeCloseTo((20 + EPSILON - 10) / 90, EPSILON);
            });

            it('numerous short skippable segments', () => {
                const segments = [
                    createSegment(10, 12, skippableCategory, ActionType.Skip), // 2s
                    createSegment(15, 18, skippableCategory, ActionType.Skip), // 3s
                    createSegment(20, 21, skippableCategory, ActionType.Skip), // 1s
                    createSegment(25, 30, skippableCategory, ActionType.Skip), // 5s
                    createSegment(32, 33, skippableCategory, ActionType.Skip), // 1s
                ]; // Total skipped = 2+3+1+5+1 = 12s. Virtual duration = 100-12 = 88s.
                previewBar.set(segments, videoDuration);

                expect(previewBar.virtualVideoDuration).toBe(88);
                // Actual time 40s. Skipped before it: 12s. Virtual time: 40-12=28s. Decimal: 28/88.
                expect(previewBar.timeToDecimal(40)).toBeCloseTo(28 / 88, EPSILON);
                // Virtual decimal for 28s (28/88) should map back to 40s.
                expect(previewBar.decimalToTime(28 / 88)).toBeCloseTo(40, EPSILON);
            });

            it('very large portion of video skipped', () => {
                // Skip 5-95. Virtual duration = 10s (0-5 and 95-100 are visible).
                const segments = [createSegment(5, 95, skippableCategory, ActionType.Skip)];
                previewBar.set(segments, videoDuration);
                expect(previewBar.virtualVideoDuration).toBe(10);

                expect(previewBar.timeToDecimal(0)).toBeCloseTo(0 / 10, EPSILON);
                expect(previewBar.timeToDecimal(4)).toBeCloseTo(4 / 10, EPSILON);
                expect(previewBar.timeToDecimal(5)).toBeCloseTo(5 / 10, EPSILON); // Start of skip
                expect(previewBar.timeToDecimal(50)).toBeCloseTo(5 / 10, EPSILON); // Middle of skip
                expect(previewBar.timeToDecimal(95)).toBeCloseTo(5 / 10, EPSILON); // End of skip (maps to virtual position of content *after* skip)
                                                                               // Corrected: timeToDecimal for actualTime=95 (end of skip) should be (95 - (95-5))/10 = 5/10.
                                                                               // The content after skip starts at virtual 5 / 10.
                expect(previewBar.timeToDecimal(96)).toBeCloseTo((96 - 90) / 10, EPSILON); // 6/10
                expect(previewBar.timeToDecimal(100)).toBeCloseTo((100 - 90) / 10, EPSILON); // 10/10

                // Decimal to time
                expect(previewBar.decimalToTime(0.4)).toBeCloseTo(4, EPSILON); // 0.4 * 10 = 4 (virtual) -> 4 (actual)
                expect(previewBar.decimalToTime(0.5)).toBeCloseTo(95, EPSILON); // 0.5 * 10 = 5 (virtual) -> end of skip = 95 (actual)
                expect(previewBar.decimalToTime(0.6)).toBeCloseTo(96, EPSILON); // 0.6 * 10 = 6 (virtual) -> 95 + (6-5) = 96 (actual)
            });
        });
        
        describe('Virtual Timeline Disabled, Native Chapters Present - Edge Cases', () => {
            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false;
                if (!previewBar.originalChapterBar) {
                     previewBar.originalChapterBar = document.createElement('div') as any;
                }
                previewBar.originalChapterBar.parentElement = { clientWidth: 1000 } as HTMLElement;
                previewBar.originalChapterBarBlocks = [
                    createMockChapterBlock(200, 2), // 0-20s, width 200px, margin 2px
                    createMockChapterBlock(298, 2), // 20-50s, width 298px, margin 2px
                    createMockChapterBlock(498, 0), // 50-100s, width 498px
                ] as unknown as NodeListOf<HTMLElement>;
                previewBar.existingChapters = [
                    createSegment(0, 20, 'chapter' as Category, ActionType.Chapter, SponsorSourceType.YouTube),
                    createSegment(20, 50, 'chapter' as Category, ActionType.Chapter, SponsorSourceType.YouTube),
                    createSegment(50, 100, 'chapter' as Category, ActionType.Chapter, SponsorSourceType.YouTube),
                ];
                previewBar.set(previewBar.existingChapters, videoDuration);
            });

            it('conversions at chapter boundaries', () => {
                // Time to Decimal
                expect(previewBar.timeToDecimal(20)).toBeCloseTo(202 / 1000, EPSILON); // End of first block (200px + 2px margin)
                expect(previewBar.timeToDecimal(50)).toBeCloseTo((202 + 300) / 1000, EPSILON); // End of second block (202px + 298px + 2px margin)
                
                // Decimal to Time
                expect(previewBar.decimalToTime(202 / 1000)).toBeCloseTo(20, EPSILON);
                expect(previewBar.decimalToTime(502 / 1000)).toBeCloseTo(50, EPSILON); // Start of third block
            });
        });
    });
});

// Minimal mock for global Config if not using jest.mock for imports
if (typeof global.Config === 'undefined') {
    global.Config = mockConfig as any;
}
if (typeof global.chrome === 'undefined') {
    global.chrome = { runtime: { id: 'test-id' } } as any;
}
if (typeof jest === 'undefined') { 
    global.jest = {
        fn: () => {
            const mockFn = (...args: any[]) => { mockFn.mock.calls.push(args); };
            mockFn.mock = { calls: [], instances: [], results: [] };
            mockFn.mockClear = () => { mockFn.mock.calls = []; mockFn.mock.instances = []; mockFn.mock.results = []; };
            mockFn.mockReturnValue = (value: any) => { mockFn.mockImplementation(() => value); return mockFn; };
            mockFn.mockImplementation = (fn: (...args: any[]) => any) => { return mockFn; };
            return mockFn as any;
        },
        spyOn: (object: any, method: any) => {
            const originalMethod = object[method];
            const mockFn = jest.fn();
            object[method] = mockFn;
            return {
                mockReturnValue: mockFn.mockReturnValue,
                mockImplementation: mockFn.mockImplementation,
                mockRestore: () => { object[method] = originalMethod; }
            };
        },
    } as any;
}
if (typeof describe === 'undefined') global.describe = ((name, fn) => fn()) as any; 
if (typeof it === 'undefined') global.it = ((name, fn) => fn()) as any; 
if (typeof expect === 'undefined') global.expect = ((actual) => ({ 
    toBe: (expected) => { if (actual !== expected) throw new Error (`Expected ${actual} to be ${expected}`); },
    toBeCloseTo: (expected, precision) => { 
        if (Math.abs(actual - expected) > (precision ?? 0)) throw new Error (`Expected ${actual} to be close to ${expected}`); 
    }
})) as any;
if (typeof beforeEach === 'undefined') global.beforeEach = ((fn) => fn()) as any;
