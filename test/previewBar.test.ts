import PreviewBar, { PreviewBarSegment } from '../src/js-components/previewBar';
import { ActionType, Category, CategorySkipOption, SegmentContainer, SponsorSourceType } from '../src/types';

// Mock Config
const mockConfig = {
    config: {
        modifyTimelineAsIfSegmentsWerentThere: false,
        barTypes: {}, 
        renderSegmentsAsChapters: false,
        showAutogeneratedChapters: true,
    },
};

// Mock getComputedStyle
global.getComputedStyle = jest.fn(() => ({
    marginRight: '0px',
}));

const mockParent = {
    // Mock any methods or properties accessed by PreviewBar constructor/methods if not covered by test=true
    // Example: querySelector, getBoundingClientRect etc.
    // For now, assuming 'test=true' bypasses most of these.
    // If originalChapterBar.parentElement.clientWidth is needed, it might be set here or on a specific mock for originalChapterBar
} as unknown as HTMLElement; // Type assertion for testing

const mockChapterVote = {} as any; 
const mockUpdateExistingChapters = jest.fn();

const EPSILON = 0.00001;

const createSegment = (start: number, end: number, category: Category, actionType: ActionType, source: SponsorSourceType = SponsorSourceType.Server): PreviewBarSegment => ({
    segment: [start, end],
    category,
    actionType,
    unsubmitted: false,
    showLarger: false,
    description: '',
    source,
});

// Helper to mock chapter blocks
const createMockChapterBlock = (widthPx: number, marginRightPx = 0): HTMLElement => {
    const element = document.createElement('div'); // Using actual HTMLElement for structure
    element.style.width = `${widthPx}px`;
    element.style.marginRight = `${marginRightPx}px`;
    return element;
};


describe('PreviewBar', () => {
    let previewBar: PreviewBar;
    let mockGetCategorySkipOption: jest.Mock;

    beforeEach(() => {
        mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false; // Default to off
        mockGetCategorySkipOption = jest.fn();
        
        global.Config = mockConfig as any; // Mock global Config

        previewBar = new PreviewBar(
            mockParent,
            false, false, false, // mobile, invidious, yttv
            mockChapterVote,
            mockUpdateExistingChapters,
            mockGetCategorySkipOption,
            true // test = true
        );

        // Default mock for originalChapterBar and its parent for clientWidth
        // Tests that need specific behavior will override this in their `beforeEach` or `it` block
        previewBar.originalChapterBar = {
            parentElement: {
                clientWidth: 1000 // Default clientWidth, e.g., 1000px
            } as HTMLElement,
            // other properties of originalChapterBar if needed by the specific test path
        } as any;
        previewBar.originalChapterBarBlocks = [] as any; // Default to no blocks
        previewBar.existingChapters = []; // Default to no existing chapters
    });

    // --- Existing tests from previous step ---
    describe('Feature Disabled: modifyTimelineAsIfSegmentsWerentThere = false', () => {
        beforeEach(() => {
            mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false;
        });

        it('virtualVideoDuration should equal videoDuration', () => {
            previewBar.set([], 100);
            expect(previewBar.virtualVideoDuration).toBe(100);
        });

        it('timeToDecimal should be linear to videoDuration if no native chapters', () => {
            previewBar.set([], 100);
            previewBar.originalChapterBarBlocks = [] as any; // Ensure no native chapters
            previewBar.existingChapters = [];
            expect(previewBar.timeToDecimal(0)).toBeCloseTo(0, EPSILON);
            expect(previewBar.timeToDecimal(50)).toBeCloseTo(0.5, EPSILON);
            expect(previewBar.timeToDecimal(100)).toBeCloseTo(1, EPSILON);
        });

        it('decimalToTime should be linear to videoDuration if no native chapters', () => {
            previewBar.set([], 100);
            previewBar.originalChapterBarBlocks = [] as any; // Ensure no native chapters
            previewBar.existingChapters = [];
            expect(previewBar.decimalToTime(0)).toBeCloseTo(0, EPSILON);
            expect(previewBar.decimalToTime(0.5)).toBeCloseTo(50, EPSILON);
            expect(previewBar.decimalToTime(1)).toBeCloseTo(100, EPSILON);
        });
    });

    describe('Feature Enabled, No Skippable Segments', () => {
        beforeEach(() => {
            mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
            mockGetCategorySkipOption.mockReturnValue(CategorySkipOption.ManualSkip);
        });

        it('virtualVideoDuration should equal videoDuration', () => {
            const segments = [createSegment(10, 20, 'sponsor' as Category, ActionType.Skip)];
            previewBar.set(segments, 100);
            expect(previewBar.virtualVideoDuration).toBe(100);
        });
    });
    // --- End of existing tests ---

    // --- New Tests from Subtask ---
    describe('Feature Flag Actuation: modifyTimelineAsIfSegmentsWerentThere', () => {
        const videoDuration = 100;
        const skippableCategory = 'sponsor' as Category;
        const skippableSegment = createSegment(20, 40, skippableCategory, ActionType.Skip); // 20s duration
        const nonSkippableSegment = createSegment(0, 10, 'intro' as Category, ActionType.Skip);

        beforeEach(() => {
            mockGetCategorySkipOption.mockImplementation((category: Category) => 
                category === skippableCategory ? CategorySkipOption.AutoSkip : CategorySkipOption.ManualSkip
            );
        });

        describe('When flag is true (Virtual Timeline Enabled)', () => {
            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
                previewBar.set([skippableSegment, nonSkippableSegment], videoDuration);
            });

            it('virtualVideoDuration is reduced by skippable segments', () => {
                expect(previewBar.virtualVideoDuration).toBe(videoDuration - 20); // 100 - 20 = 80
            });

            it('timeToDecimal reflects virtual timeline', () => {
                // Time after skippable segment: actual 50s. Skipped: 20s. Virtual time: 50-20=30s. Decimal: 30/80 = 0.375
                expect(previewBar.timeToDecimal(50)).toBeCloseTo(30 / 80, EPSILON);
            });
            
            it('skippable segment bar has zero width conceptually', () => {
                 // intervalToDecimal for the skippable segment itself should be 0
                expect(previewBar.intervalToDecimal(skippableSegment.segment[0], skippableSegment.segment[1])).toBeCloseTo(0, EPSILON);
            });
        });

        describe('When flag is false (Virtual Timeline Disabled)', () => {
            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false;
                previewBar.set([skippableSegment, nonSkippableSegment], videoDuration);
            });

            it('virtualVideoDuration equals videoDuration', () => {
                expect(previewBar.virtualVideoDuration).toBe(videoDuration);
            });

            it('timeToDecimal reflects actual timeline', () => {
                // Time after "skippable" segment (but feature is off): actual 50s. Decimal: 50/100 = 0.5
                previewBar.originalChapterBarBlocks = [] as any; // Ensure no native chapters for this part
                previewBar.existingChapters = [];
                expect(previewBar.timeToDecimal(50)).toBeCloseTo(0.5, EPSILON);
            });

            it('skippable segment bar has normal width conceptually', () => {
                // intervalToDecimal for the "skippable" segment should be its actual duration / videoDuration
                 previewBar.originalChapterBarBlocks = [] as any; 
                 previewBar.existingChapters = [];
                expect(previewBar.intervalToDecimal(skippableSegment.segment[0], skippableSegment.segment[1]))
                    .toBeCloseTo((40 - 20) / videoDuration, EPSILON);
            });
        });
    });

    describe('Time Conversion Logic Paths (decimalTimeConverter)', () => {
        const videoDuration = 100;

        describe('Path A: Native Chapters, Virtual Timeline OFF', () => {
            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false;
                
                previewBar.originalChapterBar = { parentElement: { clientWidth: 1000 } as HTMLElement } as any;
                previewBar.originalChapterBarBlocks = [
                    createMockChapterBlock(200), // Represents 0-20s, but visually 200px
                    createMockChapterBlock(300), // Represents 20-50s, but visually 300px
                    createMockChapterBlock(500), // Represents 50-100s, but visually 500px
                ] as unknown as NodeListOf<HTMLElement>; // Cast for test
                
                previewBar.existingChapters = [
                    createSegment(0, 20, 'chapter' as Category, ActionType.Chapter, SponsorSourceType.YouTube),
                    createSegment(20, 50, 'chapter' as Category, ActionType.Chapter, SponsorSourceType.YouTube),
                    createSegment(50, 100, 'chapter' as Category, ActionType.Chapter, SponsorSourceType.YouTube),
                ];
                previewBar.set(previewBar.existingChapters, videoDuration);
            });

            it('timeToDecimal respects native chapter block widths', () => {
                // Actual time 10s (middle of first 200px block): Expected decimal 0.1 (100/1000)
                expect(previewBar.timeToDecimal(10)).toBeCloseTo(0.1, EPSILON); 
                // Actual time 35s (middle of second 300px block, which starts at 200px): Expected decimal (200 + 150)/1000 = 0.35
                expect(previewBar.timeToDecimal(35)).toBeCloseTo(0.35, EPSILON);
                 // Actual time 75s (middle of third 500px block, which starts at 500px): Expected decimal (500 + 250)/1000 = 0.75
                expect(previewBar.timeToDecimal(75)).toBeCloseTo(0.75, EPSILON);
            });

            it('decimalToTime respects native chapter block widths', () => {
                // Decimal 0.1 (100px into 1000px total) -> maps to 10s (halfway into first 0-20s chapter)
                expect(previewBar.decimalToTime(0.1)).toBeCloseTo(10, EPSILON);
                // Decimal 0.35 (350px into 1000px total) -> maps to 35s (halfway into second 20-50s chapter)
                expect(previewBar.decimalToTime(0.35)).toBeCloseTo(35, EPSILON);
                 // Decimal 0.75 (750px into 1000px total) -> maps to 75s (halfway into third 50-100s chapter)
                expect(previewBar.decimalToTime(0.75)).toBeCloseTo(75, EPSILON);
            });
        });

        describe('Path B: Virtual Timeline ON (native chapter data should be ignored for scaling)', () => {
            const skippableCategory = 'sponsor' as Category;
            const skippableSegment = createSegment(20, 40, skippableCategory, ActionType.Skip); // 20s duration

            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
                mockGetCategorySkipOption.mockImplementation((category: Category) => 
                    category === skippableCategory ? CategorySkipOption.AutoSkip : CategorySkipOption.ManualSkip
                );

                // Mock native chapters, but they should be ignored by virtual timeline logic for scaling
                previewBar.originalChapterBar = { parentElement: { clientWidth: 1000 } } as any;
                previewBar.originalChapterBarBlocks = [ createMockChapterBlock(1000) ] as unknown as NodeListOf<HTMLElement>;
                previewBar.existingChapters = [ createSegment(0, 100, 'chapter' as Category, ActionType.Chapter, SponsorSourceType.YouTube) ];
                
                previewBar.set([skippableSegment], videoDuration); // Virtual duration = 80s
            });

            it('timeToDecimal uses virtual timeline scaling, ignoring native chapters', () => {
                // Actual 50s. Skipped 20s. Virtual time: 30s. Decimal: 30/80 = 0.375
                expect(previewBar.timeToDecimal(50)).toBeCloseTo(30 / 80, EPSILON);
            });

            it('decimalToTime uses virtual timeline scaling, ignoring native chapters', () => {
                // Virtual decimal 0.5 (40s on virtual 80s timeline). Actual: 40s (virtual) + 20s (skipped) = 60s
                // decimalToTime(0.5) should be actual 60.
                // Virtual time = 0.5 * 80 = 40.
                // This 40s of virtual progress occurs after the 20s skip (20-40).
                // So, actual time = 20 (non-skipped part before segment) + 20 (duration of skipped segment) + (40 - 20 (non-skipped part before segment))
                // = 20 (passed) + 20 (skipped part) + 20 (additional after skip) = 60
                 expect(previewBar.decimalToTime(0.5)).toBeCloseTo(60, EPSILON);
            });
        });

        describe('Path B: Virtual Timeline OFF, NO native chapters', () => {
            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = false;
                previewBar.originalChapterBarBlocks = [] as any; // No native chapters
                previewBar.existingChapters = [];
                previewBar.set([], videoDuration);
            });

            it('timeToDecimal is linear to videoDuration', () => {
                expect(previewBar.timeToDecimal(50)).toBeCloseTo(0.5, EPSILON);
            });

            it('decimalToTime is linear to videoDuration', () => {
                expect(previewBar.decimalToTime(0.5)).toBeCloseTo(50, EPSILON);
            });
        });
    });
    
    // Re-include previous tests to ensure they still pass with new structure
    describe('Previously Existing Tests (Re-check)', () => {
        // (Copied from previous version of the file, ensure they still make sense)
        describe('Feature Enabled, One Skippable Segment (ActionType.Skip, AutoSkip) - Original Detailed Cases', () => {
            const videoDuration = 100;
            const skippableCategory = 'sponsor' as Category;
            
            beforeEach(() => {
                mockConfig.config.modifyTimelineAsIfSegmentsWerentThere = true;
                mockGetCategorySkipOption.mockImplementation((category: Category) => {
                    if (category === skippableCategory) {
                        return CategorySkipOption.AutoSkip;
                    }
                    return CategorySkipOption.ManualSkip;
                });
            });
    
            const testCases = [
                 { name: 'at the beginning', segment: createSegment(0, 20, skippableCategory, ActionType.Skip), nonSkippableTimeBefore: -1, timeWithinSkip: 10, timeAfterSkip: 30, virtualClickForTimeAfterSkip: (30-20)/(100-20)},
                 { name: 'in the middle', segment: createSegment(40, 60, skippableCategory, ActionType.Skip), nonSkippableTimeBefore: 30, timeWithinSkip: 50, timeAfterSkip: 70, virtualClickForTimeAfterSkip: (70-20)/(100-20) },
                 { name: 'at the end', segment: createSegment(80, 100, skippableCategory, ActionType.Skip), nonSkippableTimeBefore: 70, timeWithinSkip: 90, timeAfterSkip: -1, virtualClickForTimeAfterSkip: -1 }
            ];
    
            testCases.forEach(tc => {
                describe(`Skippable segment ${tc.name}`, () => {
                    beforeEach(() => {
                        previewBar.set([tc.segment], videoDuration);
                    });
    
                    it('virtualVideoDuration should be reduced', () => {
                        expect(previewBar.virtualVideoDuration).toBe(videoDuration - (tc.segment.segment[1] - tc.segment.segment[0]));
                    });
    
                    it('timeToDecimal: actual times before skippable segment', () => {
                        if (tc.nonSkippableTimeBefore !== -1) {
                            const expectedDecimal = tc.nonSkippableTimeBefore / previewBar.virtualVideoDuration;
                            expect(previewBar.timeToDecimal(tc.nonSkippableTimeBefore)).toBeCloseTo(expectedDecimal, EPSILON);
                        }
                    });
                    
                    it('timeToDecimal: actual times within skippable segment should map to virtual start of segment', () => {
                        const virtualTimeOfSegmentStart = tc.segment.segment[0]; // Actual time of start
                        const expectedDecimalForStart = virtualTimeOfSegmentStart / previewBar.virtualVideoDuration; // Virtual position of this actual start
                        expect(previewBar.timeToDecimal(tc.timeWithinSkip)).toBeCloseTo(expectedDecimalForStart, EPSILON);
                    });
    
                    it('timeToDecimal: actual times after skippable segment', () => {
                        if (tc.timeAfterSkip !== -1) {
                            const segmentDuration = tc.segment.segment[1] - tc.segment.segment[0];
                            const expectedDecimal = (tc.timeAfterSkip - segmentDuration) / previewBar.virtualVideoDuration;
                            expect(previewBar.timeToDecimal(tc.timeAfterSkip)).toBeCloseTo(expectedDecimal, EPSILON);
                        }
                    });
    
                    it('decimalToTime: maps virtual decimal to correct actual time after skip', () => {
                        if (tc.virtualClickForTimeAfterSkip !== -1 && tc.timeAfterSkip !== -1) {
                             expect(previewBar.decimalToTime(tc.virtualClickForTimeAfterSkip)).toBeCloseTo(tc.timeAfterSkip, EPSILON);
                        }
                    });
                    
                    it('decimalToTime: virtual decimal at virtual start of skippable segment maps to actual end of skippable segment', () => {
                        const virtualTimeOfSegmentStartActual = tc.segment.segment[0];
                        const virtualDecimalOfSegmentStart = virtualTimeOfSegmentStartActual / previewBar.virtualVideoDuration;
                        expect(previewBar.decimalToTime(virtualDecimalOfSegmentStart)).toBeCloseTo(tc.segment.segment[1], EPSILON);
                    });
                    
                    it('skippable segment bar should have zero width', () => {
                        const barElement = previewBar.createBar(tc.segment);
                        const expectedLeft = previewBar.timeToPercentage(tc.segment.segment[0]);
                        const expectedRight = previewBar.timeToRightPercentage(tc.segment.segment[0]);
                        expect(barElement.style.left).toBe(expectedLeft);
                        expect(barElement.style.right).toBe(expectedRight);
                        expect(previewBar.intervalToDecimal(tc.segment.segment[0], tc.segment.segment[1])).toBeCloseTo(0, EPSILON);
                    });
                });
            });
        });
    });
});

// Minimal mock for global Config if not using jest.mock for imports
if (typeof global.Config === 'undefined') {
    global.Config = mockConfig as any;
}
if (typeof global.chrome === 'undefined') {
    global.chrome = { runtime: { id: 'test-id' } } as any;
}
