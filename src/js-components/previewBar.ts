/*
Based on code from
https://github.com/videosegments/videosegments/commits/f1e111bdfe231947800c6efdd51f62a4e7fef4d4/segmentsbar/segmentsbar.js
*/

'use strict';

import Config from "../config";
import { ChapterVote } from "../render/ChapterVote";
import { ActionType, Category, CategorySkipOption, SegmentContainer, SponsorHideType, SponsorSourceType, SponsorTime } from "../types"; // Added CategorySkipOption
import { partition } from "../utils/arrayUtils";
import { DEFAULT_CATEGORY, shortCategoryName } from "../utils/categoryUtils";
import { normalizeChapterName } from "../utils/exporter";
import { findValidElement } from "../../maze-utils/src/dom";
import { addCleanupListener } from "../../maze-utils/src/cleanup";
import { hasAutogeneratedChapters, isVisible } from "../utils/pageUtils";
import { isVorapisInstalled } from "../utils/compatibility";
import { isOnYTTV } from "../../maze-utils/src/video";

const TOOLTIP_VISIBLE_CLASS = 'sponsorCategoryTooltipVisible';
const MIN_CHAPTER_SIZE = 0.003;

export interface PreviewBarSegment {
    segment: [number, number];
    category: Category;
    actionType: ActionType;
    unsubmitted: boolean;
    showLarger: boolean;
    description: string;
    source: SponsorSourceType;
    requiredSegment?: boolean;
    selectedSegment?: boolean;
}

interface ChapterGroup extends SegmentContainer {
    originalDuration: number;
    actionType: ActionType;
}

class PreviewBar {
    container: HTMLUListElement;
    categoryTooltip?: HTMLDivElement;
    categoryTooltipContainer?: HTMLElement;
    chapterTooltip?: HTMLDivElement;

    // ScrubTooltips for YTTV only
    categoryScrubTooltip?: HTMLDivElement;
    categoryScrubTooltipContainer?: HTMLElement;
    chapterScrubTooltip?: HTMLDivElement;

    lastSmallestSegment: Record<string, {
        index: number;
        segment: PreviewBarSegment;
    }> = {};

    parent: HTMLElement;
    onMobileYouTube: boolean;
    onInvidious: boolean;
    onYTTV: boolean;
    progressBar: HTMLElement;

    segments: PreviewBarSegment[] = [];
    hasYouTubeChapters = false;
    existingChapters: PreviewBarSegment[] = [];
    videoDuration = 0;
    virtualVideoDuration = 0; // Added
    updateExistingChapters: () => void;
    lastChapterUpdate = 0;

    // For chapter bar
    hoveredSection: HTMLElement;
    customChaptersBar: HTMLElement;
    chaptersBarSegments: PreviewBarSegment[];
    chapterVote: ChapterVote;
    originalChapterBar: HTMLElement;
    originalChapterBarBlocks: NodeListOf<HTMLElement>;
    chapterMargin: number;
    lastRenderedSegments: PreviewBarSegment[];
    unfilteredChapterGroups: ChapterGroup[];
    chapterGroups: ChapterGroup[];
    private getCategorySkipOption: (category: Category) => CategorySkipOption | undefined;
    private testMode: boolean; // Added for test mode


    constructor(
        parent: HTMLElement, 
        onMobileYouTube: boolean, 
        onInvidious: boolean, 
        onYTTV: boolean, 
        chapterVote: ChapterVote, 
        updateExistingChapters: () => void, 
        getCategorySkipOption: (category: Category) => CategorySkipOption | undefined, // Added
        test = false
    ) {
        this.testMode = test; // Store test mode
        this.container = document.createElement('ul');
        this.container.id = 'previewbar';

        if (!this.testMode && onYTTV) { // Guard DOM manipulation
            this.container.classList.add("sponsorblock-yttv-container");
        }

        this.parent = parent; // Can be a mock in test mode
        this.onMobileYouTube = onMobileYouTube;
        this.onInvidious = onInvidious;
        this.onYTTV = onYTTV;
        this.chapterVote = chapterVote;
        this.updateExistingChapters = updateExistingChapters;
        this.getCategorySkipOption = getCategorySkipOption; // Added

        // These methods will be refactored to be test-mode aware
        this.updatePageElements(); 
        this.createElement(); 
        this.createChapterMutationObservers();
        this.setupHoverText();
    }

    setupHoverText(): void {
        if (this.testMode || this.onMobileYouTube || this.onInvidious) return; // Bypass if in test mode or mobile/invidious

        // delete old ones
        // This is a global query, might be problematic if not mocked in tests, but setupHoverText is bypassed in testMode.
        document.querySelectorAll(`.sponsorCategoryTooltip`) 
            .forEach((e) => e.remove());

        // Create label placeholder
        this.categoryTooltip = document.createElement("div");
        if (isOnYTTV()) {
            this.categoryTooltip.className = "sponsorCategoryTooltip";
        } else {
            this.categoryTooltip.className = "ytp-tooltip-title sponsorCategoryTooltip";
        }
        this.chapterTooltip = document.createElement("div");
        if (isOnYTTV()) {
            this.chapterTooltip.className = "sponsorCategoryTooltip";
        } else {
            this.chapterTooltip.className = "ytp-tooltip-title sponsorCategoryTooltip";
        }

        if (isOnYTTV()) {
            this.categoryScrubTooltip = document.createElement("div");
            this.categoryScrubTooltip.className = "sponsorCategoryTooltip";
            this.chapterScrubTooltip = document.createElement("div");
            this.chapterScrubTooltip.className = "sponsorCategoryTooltip";
        }

        // global chapter tooltip or duration tooltip
        // YT, Vorapis, unknown, YTTV
        // Global queries will need careful mocking in tests if this method is not fully bypassed.
        // For now, keeping the initial bypass for testMode.
        const tooltipTextWrapper = document.querySelector(".ytp-tooltip-text-wrapper, .ytp-progress-tooltip-text-container, .yssi-slider .ys-seek-details .time-info-bar") ?? document.querySelector("#progress-bar-container.ytk-player > #hover-time-info");
        if (!tooltipTextWrapper) return; // Early exit if essential element not found
        
        const originalTooltip = tooltipTextWrapper.querySelector(".ytp-tooltip-title:not(.sponsorCategoryTooltip), .ytp-progress-tooltip-text:not(.sponsorCategoryTooltip), .current-time:not(.sponsorCategoryTooltip)") as HTMLElement;
        if (!originalTooltip || !tooltipTextWrapper.parentElement) return;

        // Grab the tooltip from the text wrapper as the tooltip doesn't have its classes on init
        this.categoryTooltipContainer = tooltipTextWrapper.parentElement;
        // YT, Vorapis, YTTV
        const titleTooltip = tooltipTextWrapper.querySelector(".ytp-tooltip-title, .ytp-progress-tooltip-text, .current-time") as HTMLElement;
        if (!this.categoryTooltipContainer || !titleTooltip) return;

        // DOM manipulations
        tooltipTextWrapper.insertBefore(this.categoryTooltip, titleTooltip.nextSibling);
        tooltipTextWrapper.insertBefore(this.chapterTooltip, titleTooltip.nextSibling);

        if (isOnYTTV()) {
            const scrubTooltipTextWrapper = document.querySelector(".yssi-slider .ysl-filmstrip-lens .time-info-bar");
            if (scrubTooltipTextWrapper && this.categoryScrubTooltip && this.chapterScrubTooltip) { // Check if elements exist
                scrubTooltipTextWrapper.appendChild(this.categoryScrubTooltip);
                scrubTooltipTextWrapper.appendChild(this.chapterScrubTooltip);
            }
        }

        const seekBar = (document.querySelector(".ytp-progress-bar-container, .ypcs-scrub-slider-slot.ytu-player-controls"));
        if (!seekBar) return; // Essential for hover logic

        let mouseOnSeekBar = false;

        // Event listeners for actual browser environment
        seekBar.addEventListener("mouseenter", () => { mouseOnSeekBar = true; });
        seekBar.addEventListener("mouseleave", () => { mouseOnSeekBar = false; });

        seekBar.addEventListener("mousemove", (e: MouseEvent) => {
            if (!mouseOnSeekBar || !this.categoryTooltip || !this.categoryTooltipContainer || !chrome.runtime?.id) return;
            
            const seekBarRect = seekBar.getBoundingClientRect();
            if (!seekBarRect || seekBarRect.width === 0) return; // Avoid division by zero if rect is invalid

            let noYoutubeChapters = !!tooltipTextWrapper.querySelector(".ytp-tooltip-text.ytp-tooltip-text-no-title, .ytp-progress-tooltip-timestamp");
            const timeInSeconds = this.decimalToTime((e.clientX - seekBarRect.x) / seekBarRect.width);

            // Find the segment at that location, using the shortest if multiple found
            const [normalSegments, chapterSegments] =
                partition(this.segments,
                    (segment) => segment.actionType !== ActionType.Chapter);
            let mainSegment = this.getSmallestSegment(timeInSeconds, normalSegments, "normal");
            let secondarySegment = this.getSmallestSegment(timeInSeconds, chapterSegments, "chapter");
            if (mainSegment === null && secondarySegment !== null) {
                mainSegment = secondarySegment;
                secondarySegment = this.getSmallestSegment(timeInSeconds, chapterSegments.filter((s) => s !== secondarySegment));
            }

            const hasAYouTubeChapterRemoved = this.hasYouTubeChapters
                || (!Config.config.showAutogeneratedChapters && hasAutogeneratedChapters());
            if (hasAYouTubeChapterRemoved) {
                // Hide original tooltip if some chapter has been filtered out
                originalTooltip.style.display = "none";
                noYoutubeChapters = true;

                originalTooltip.classList.add("sponsorTooltipHasYTChapters");
            } else {
                originalTooltip.classList.remove("sponsorTooltipHasYTChapters");
            }

            if (mainSegment === null && secondarySegment === null) {
                if (!hasAYouTubeChapterRemoved) {
                    this.categoryTooltipContainer.classList.remove(TOOLTIP_VISIBLE_CLASS);
                    originalTooltip.style.removeProperty("display");
                }
                if (this.onYTTV) {
                    this.setTooltipTitle(mainSegment, this.categoryTooltip);
                    this.setTooltipTitle(secondarySegment, this.chapterTooltip);
                    this.setTooltipTitle(mainSegment, this.categoryScrubTooltip);
                    this.setTooltipTitle(secondarySegment, this.chapterScrubTooltip);
                }
            } else {
                this.categoryTooltipContainer.classList.add(TOOLTIP_VISIBLE_CLASS);
                if (mainSegment !== null && secondarySegment !== null) {
                    this.categoryTooltipContainer.classList.add("sponsorTwoTooltips");
                    originalTooltip.classList.remove("sponsorTooltipHasYTChapters");
                } else {
                    this.categoryTooltipContainer.classList.remove("sponsorTwoTooltips");
                }

                this.setTooltipTitle(mainSegment, this.categoryTooltip);
                this.setTooltipTitle(secondarySegment, this.chapterTooltip);
                if (this.onYTTV) {
                    this.setTooltipTitle(mainSegment, this.categoryScrubTooltip);
                    this.setTooltipTitle(secondarySegment, this.chapterScrubTooltip);
                }

                if (isVorapisInstalled()) {
                    const tooltipParent = tooltipTextWrapper.parentElement!;
                    tooltipParent.classList.add("with-text");
                }

                if (normalizeChapterName(originalTooltip.textContent) === normalizeChapterName(this.categoryTooltip.textContent)
                        || normalizeChapterName(originalTooltip.textContent) === normalizeChapterName(this.chapterTooltip.textContent)) {
                    if (originalTooltip.style.display !== "none") originalTooltip.style.display = "none";
                    noYoutubeChapters = true;
                } else if (originalTooltip.style.display === "none") {
                    originalTooltip.style.removeProperty("display");
                }

                // To prevent offset issue
                this.categoryTooltip.style.right = titleTooltip.style.right;
                this.chapterTooltip.style.right = titleTooltip.style.right;
                this.categoryTooltip.style.textAlign = titleTooltip.style.textAlign;
                this.chapterTooltip.style.textAlign = titleTooltip.style.textAlign;
            }

            // Used to prevent overlapping
            this.categoryTooltip.classList.toggle("ytp-tooltip-text-no-title", noYoutubeChapters);
            this.chapterTooltip.classList.toggle("ytp-tooltip-text-no-title", noYoutubeChapters);
        });
    }

    private setTooltipTitle(segment: PreviewBarSegment, tooltip: HTMLElement): void {
        if (segment) {
            const name = segment.description || shortCategoryName(segment.category);
            if (segment.unsubmitted) {
                tooltip.textContent = chrome.i18n.getMessage("unsubmitted") + " " + name;
            } else {
                tooltip.textContent = name;
            }

            tooltip.style.removeProperty("display");
        } else {
            tooltip.style.display = "none";
        }
    }

    createElement(parent?: HTMLElement): void { // `parent` argument is shadowed by `this.parent`
        if (parent && !this.testMode) this.parent = parent; // Only assign if not in test and parent is provided

        if (this.onMobileYouTube && this.container) {
            this.container.style.transform = "none";
        } else if (!this.onInvidious && this.container) {
            this.container.classList.add("sbNotInvidious");
        }

        // On the seek bar - DOM manipulation, guard with testMode and parent existence
        if (!this.testMode && this.parent && this.container) {
            if (this.onYTTV) {
                // order of sibling elements matters on YTTV
                if (this.parent.firstChild?.nextSibling?.nextSibling) { // Ensure elements exist
                    this.parent.insertBefore(this.container, this.parent.firstChild.nextSibling.nextSibling);
                } else {
                    this.parent.appendChild(this.container); // Fallback append
                }
            } else {
                this.parent.prepend(this.container);
            }
        }
    }

    clear(): void {
        if (this.container) { // Check if container exists
            while (this.container.firstChild) {
                this.container.removeChild(this.container.firstChild);
            }
        }

        if (this.customChaptersBar) this.customChaptersBar.style.display = "none";
        
        if (!this.testMode && this.originalChapterBar?.style) { // Guard style access
            this.originalChapterBar.style.removeProperty("display");
        }
        
        this.chapterVote?.setVisibility(false);

        if (!this.testMode) { // Guard global querySelectorAll
            document.querySelectorAll(`.sponsorBlockChapterBar`).forEach((e) => {
                if (e !== this.customChaptersBar) {
                    e.remove();
                }
            });
        }
    }

    set(segments: PreviewBarSegment[], videoDuration: number): void {
        this.segments = segments ?? [];
        this.videoDuration = videoDuration ?? 0;
        this.virtualVideoDuration = this.videoDuration; 
        this.hasYouTubeChapters = segments?.some((segment) => segment.source === SponsorSourceType.YouTube) ?? false;

        // Remove unnecessary original chapters if submitted replacements exist
        for (const chapter of this.segments.filter((s) => s.actionType === ActionType.Chapter && s.source === SponsorSourceType.Server)) {
            const segmentDuration = chapter.segment[1] - chapter.segment[0];
            
            const duplicate = this.segments.find((s) => s.actionType === ActionType.Chapter 
                && s.source === SponsorSourceType.YouTube
                && Math.abs(s.segment[0] - chapter.segment[0]) < Math.min(3, segmentDuration / 3)
                && Math.abs(s.segment[1] - chapter.segment[1]) < Math.min(3, segmentDuration / 3));
            
            if (duplicate) {
                const index = this.segments.indexOf(duplicate);
                this.segments.splice(index, 1);
            }
        }

        this.updatePageElements();
        // Sometimes video duration is inaccurate, pull from accessibility info
        const ariaDuration = parseInt(this.progressBar?.getAttribute('aria-valuemax')) ?? 0;
        const multipleActiveVideos = [...document.querySelectorAll("video")].filter((v) => isVisible(v)).length > 1;
        if (!multipleActiveVideos && ariaDuration && Math.abs(ariaDuration - this.videoDuration) > 3) {
            this.videoDuration = ariaDuration;
        }

        this.update();

        // Placeholder for feature flag check
        const isModifyTimelineEnabled = () => {
            // In a real scenario, this would check Config.config.modifyTimelineAsIfSegmentsWerentThere
            // For now, let's assume it's true for testing purposes if you want to see the effect.
            // return true; 
            return typeof Config !== 'undefined' && Config.config?.modifyTimelineAsIfSegmentsWerentThere;
        };

        // Defines if a segment should be considered "skipped" for timeline alteration
        const isTimelineModifyingSegment = (segment: PreviewBarSegment): boolean => {
            if (!this.getCategorySkipOption) return false; // Guard if function not provided
            const skipOption = this.getCategorySkipOption(segment.category);
            return segment.actionType === ActionType.Skip && skipOption === CategorySkipOption.AutoSkip;
        };

        if (isModifyTimelineEnabled()) {
            let totalSkippedDuration = 0;
            if (this.segments) {
                for (const segment of this.segments) {
                    if (isTimelineModifyingSegment(segment)) {
                        totalSkippedDuration += (segment.segment[1] - segment.segment[0]);
                    }
                }
            }
            this.virtualVideoDuration = Math.max(0, this.videoDuration - totalSkippedDuration);
        } else {
            this.virtualVideoDuration = this.videoDuration;
        }
    }

    private updatePageElements(): void {
        // YT, Vorapis v3
        // Only perform DOM queries if not in test mode or if essential elements might be mocked
        if (!this.testMode) {
            const allProgressBars = document.querySelectorAll(".ytp-progress-bar, .ytp-progress-bar-container > .html5-progress-bar > .ytp-progress-list") as NodeListOf<HTMLElement>;
            this.progressBar = findValidElement(allProgressBars) ?? allProgressBars?.[0];

            if (this.progressBar) {
                const newChapterBar = this.progressBar.querySelector(".ytp-chapters-container:not(.sponsorBlockChapterBar)") as HTMLElement;
                if (this.originalChapterBar !== newChapterBar) {
                    this.originalChapterBar?.style?.removeProperty("display");
                    this.originalChapterBar = newChapterBar;
                }
            }
        } else {
            // In test mode, these might be explicitly mocked by the test setup if needed
            // this.progressBar = null; 
            // this.originalChapterBar = null;
        }
    }

    private update(): void {
        this.clear(); // clear now respects testMode for DOM parts
        
        if (!this.testMode) { // Guard DOM specific logic
            const chapterChevron = this.getChapterChevron();
            if (!this.segments) {
                chapterChevron?.style?.removeProperty("display");
            }
        }

        this.chapterMargin = 2;
        // Access to originalChapterBarBlocks depends on originalChapterBar being set (usually via updatePageElements)
        if (this.originalChapterBar) { 
            this.originalChapterBarBlocks = this.originalChapterBar.querySelectorAll(":scope > div") as NodeListOf<HTMLElement>;
            if (this.segments) { // Ensure segments is not null
                 this.existingChapters = this.segments.filter((s) => s.source === SponsorSourceType.YouTube).sort((a, b) => a.segment[0] - b.segment[0]);
            } else {
                this.existingChapters = [];
            }

            if (this.existingChapters?.length > 0 && this.originalChapterBarBlocks?.[0]?.style) { // Guard style access
                const margin = parseFloat(this.originalChapterBarBlocks?.[0]?.style?.marginRight?.replace("px", ""));
                if (margin) this.chapterMargin = margin;
            }
        }


        const sortedSegments = this.segments?.sort(({ segment: a }, { segment: b }) => { // Ensure segments is not null
            return (b[1] - b[0]) - (a[1] - a[0]);
        }) || [];

        for (const segment of sortedSegments) {
            if (segment.actionType === ActionType.Chapter) continue;
            const bar = this.createBar(segment);
            if (this.container) this.container.appendChild(bar); // Guard container
        }

        this.createChaptersBar(this.segments?.sort((a, b) => a.segment[0] - b.segment[0]) || []); // Ensure segments is not null

        if (!this.testMode) { // Guard DOM specific logic
            const chapterChevron = this.getChapterChevron();
            if (chapterChevron) {
                if (this.segments?.some((segment) => segment.source === SponsorSourceType.YouTube)) { // Ensure segments is not null
                    chapterChevron.style.removeProperty("display");
                } else if (this.segments) {
                    chapterChevron.style.display = "none";
                }
            }
        }
    }

    createBar(barSegment: PreviewBarSegment): HTMLLIElement {
        const { category, unsubmitted, segment, showLarger } = barSegment;

        const bar = document.createElement('li'); // This can run in tests
        bar.classList.add('previewbar');
        if (barSegment.requiredSegment) bar.classList.add("requiredSegment");
        if (barSegment.selectedSegment) bar.classList.add("selectedSegment");
        bar.innerHTML = showLarger ? '&nbsp;&nbsp;' : '&nbsp;';

        const fullCategoryName = (unsubmitted ? 'preview-' : '') + category;
        bar.setAttribute('sponsorblock-category', fullCategoryName);
        
        // Config access should be fine, barTypes might need mock in tests if not already
        bar.style.backgroundColor = `var(--sb-category-${fullCategoryName})`;
        if (!this.onMobileYouTube && Config.config.barTypes[fullCategoryName]?.opacity) {
             bar.style.opacity = Config.config.barTypes[fullCategoryName]?.opacity;
        }

        bar.style.position = "absolute";

        const modifyTimelineEnabled = typeof Config !== 'undefined' && Config.config?.modifyTimelineAsIfSegmentsWerentThere;

        // Defines if a segment bar should be collapsed (made zero-width) on the virtual timeline
        const shouldCollapseSegmentBar = (segment: PreviewBarSegment): boolean => {
            if (!this.getCategorySkipOption) return false;
            const skipOption = this.getCategorySkipOption(segment.category);
            // Only collapse ActionType.Skip segments that are set to AutoSkip
            return segment.actionType === ActionType.Skip && skipOption === CategorySkipOption.AutoSkip;
        };

        const actualStartTime = segment[1] ? Math.min(this.videoDuration, segment[0]) : segment[0];
        const actualEndTime = Math.min(this.videoDuration, segment[1]);
        const actualDuration = actualEndTime - actualStartTime;

        if (modifyTimelineEnabled && shouldCollapseSegmentBar(barSegment)) {
            // Skippable (AutoSkip + ActionType.Skip) segments are rendered with zero effective width.
            // Their 'position' is at their virtual start time.
            // this.timeToPercentage will convert actualStartTime to its virtual percentage.
            bar.style.left = this.timeToPercentage(actualStartTime);
            // Set right to ensure zero width by using the same time for the end point's "right" calculation.
            bar.style.right = this.timeToRightPercentage(actualStartTime);
        } else {
            // For non-skippable segments, or if timeline modification is disabled.
            // timeToPercentage/RightPercentage will use virtualVideoDuration and perform time mapping if enabled.
            // We pass the *actual* start and end times of the segment.
            bar.style.left = this.timeToPercentage(actualStartTime);
            if (actualDuration > 0) {
                bar.style.right = this.timeToRightPercentage(actualEndTime);
            } else { // Zero duration segment, make it end where it started.
                 bar.style.right = this.timeToRightPercentage(actualStartTime);
            }
        }

        if (this.chapterFilter(barSegment) && segment[1] < this.videoDuration) {
            bar.style.marginRight = `${this.chapterMargin}px`;
        }

        if (this.onYTTV) {
            bar.classList.add("previewbar-yttv");
        }

        return bar;
    }

    createChaptersBar(segments: PreviewBarSegment[]): void {
        // Heavy DOM interaction, guard most if in test mode or if elements are missing
        if (!this.testMode && (!this.progressBar || !this.originalChapterBar || this.originalChapterBar.childElementCount <= 0)) {
            if (this.originalChapterBar) this.originalChapterBar.style.removeProperty("display");
            document.querySelectorAll(".sponsorBlockChapterBar").forEach((element) => element.remove());
            this.customChaptersBar = null;
            return;
        }

        const remakingBar = segments !== this.lastRenderedSegments;
        if (remakingBar) {
            this.lastRenderedSegments = segments;
            this.unfilteredChapterGroups = this.createChapterRenderGroups(segments);
        }
        
        // Logic for deciding whether to show custom chapters or default to YouTube's
        // This part is primarily logic and should be runnable in tests.
        if ((segments.every((s) => s.source === SponsorSourceType.YouTube) ||
            (!Config.config.renderSegmentsAsChapters && segments.every((s) => s.actionType !== ActionType.Chapter || s.source === SponsorSourceType.YouTube))) &&
            !(hasAutogeneratedChapters() && !Config.config.showAutogeneratedChapters)) {

            if (this.customChaptersBar) this.customChaptersBar.style.display = "none";
            if (!this.testMode && this.originalChapterBar) this.originalChapterBar.style.removeProperty("display");
            return;
        }

        const filteredSegments = segments?.filter((segment) => this.chapterFilter(segment));
        if (filteredSegments) {
            let groups = this.unfilteredChapterGroups;
            if (filteredSegments.length !== segments.length) {
                groups = this.createChapterRenderGroups(filteredSegments);
            }
            this.chapterGroups = groups?.filter((segment) => this.chapterGroupFilter(segment)); // Ensure groups is not null

            if (groups && this.chapterGroups && groups.length !== this.chapterGroups.length) {
                for (let i = 1; i < this.chapterGroups.length; i++) {
                    if (this.chapterGroups[i].segment[0] !== this.chapterGroups[i - 1].segment[1]) {
                        this.chapterGroups[i - 1].segment[1] = this.chapterGroups[i].segment[0];
                    }
                }
            }
        } else {
            this.chapterGroups = this.unfilteredChapterGroups;
        }
        
        if (this.chapterGroups && this.chapterGroups.length === 0 && !Config.config.showAutogeneratedChapters && hasAutogeneratedChapters()) {
             this.chapterGroups = [{ segment: [0, this.videoDuration], originalDuration: 0, actionType: null }];
        }

        if (!this.chapterGroups || this.chapterGroups.length <= 0) {
            if (this.customChaptersBar) this.customChaptersBar.style.display = "none";
            if (!this.testMode && this.originalChapterBar) this.originalChapterBar.style.removeProperty("display");
            return;
        }

        // Heavy DOM part starts here
        if (this.testMode) return; // Bypass further DOM manipulation in test mode

        let createFromScratch = false;
        if (!this.customChaptersBar || (this.progressBar && !this.progressBar.contains(this.customChaptersBar))) {
            document.querySelectorAll(".sponsorBlockChapterBar").forEach((element) => element.remove());
            if (this.originalChapterBar) { // Ensure originalChapterBar exists before cloning
                 createFromScratch = true;
                 this.customChaptersBar = this.originalChapterBar.cloneNode(true) as HTMLElement;
                 this.customChaptersBar.classList.add("sponsorBlockChapterBar");
            } else {
                return; // Cannot proceed without originalChapterBar
            }
        }
        
        if (!this.customChaptersBar) return; // Should not happen if createFromScratch was true and successful

        this.customChaptersBar.style.display = "none";
        const originalSections = this.customChaptersBar.querySelectorAll(".ytp-chapter-hover-container");
        const originalSection = originalSections[0];

        if (originalSections.length > this.chapterGroups.length) {
            for (let i = originalSections.length - 1; i >= this.chapterGroups.length; i--) {
                if (this.customChaptersBar) this.customChaptersBar.removeChild(originalSections[i]);
            }
        }

        for (let i = 0; i < this.chapterGroups.length; i++) {
            const chapter = this.chapterGroups[i].segment;
            let newSection = originalSections[i] as HTMLElement;
            if (!newSection && originalSection) { // Ensure originalSection exists for cloning
                newSection = originalSection.cloneNode(true) as HTMLElement;
                this.firstTimeSetupChapterSection(newSection);
                if (this.customChaptersBar) this.customChaptersBar.appendChild(newSection);
            } else if (createFromScratch) {
                this.firstTimeSetupChapterSection(newSection);
            }
            if (newSection) this.setupChapterSection(newSection, chapter[0], chapter[1], i !== this.chapterGroups.length - 1);
        }

        if (this.originalChapterBar) this.originalChapterBar.style.display = "none";
        if (this.customChaptersBar) this.customChaptersBar.style.removeProperty("display");

        if (createFromScratch && this.progressBar && this.customChaptersBar) {
            if (this.container?.parentElement === this.progressBar) {
                this.progressBar.insertBefore(this.customChaptersBar, this.container.nextSibling);
            } else {
                this.progressBar.prepend(this.customChaptersBar);
            }
        }

        if (remakingBar && this.originalChapterBar && this.progressBar) {
            this.updateChapterAllMutation(this.originalChapterBar, this.progressBar, true);
        }
    }

    createChapterRenderGroups(segments: PreviewBarSegment[]): ChapterGroup[] {
        if (!segments) return []; // Handle null input for segments
        const result: ChapterGroup[] = [];

        segments?.forEach((segment, index) => {
            const latestChapter = result[result.length - 1];
            if (latestChapter && latestChapter.segment[1] > segment.segment[0]) {
                const segmentDuration = segment.segment[1] - segment.segment[0];
                if (segment.segment[0] < latestChapter.segment[0]
                        || segmentDuration < latestChapter.originalDuration) {
                    // Remove latest if it starts too late
                    let latestValidChapter = latestChapter;
                    const chaptersToAddBack: ChapterGroup[] = []
                    while (latestValidChapter?.segment[0] >= segment.segment[0]) {
                        const invalidChapter = result.pop();
                        if (invalidChapter.segment[1] > segment.segment[1]) {
                            if (invalidChapter.segment[0] === segment.segment[0]) {
                                invalidChapter.segment[0] = segment.segment[1];
                            }

                            chaptersToAddBack.push(invalidChapter);
                        }
                        latestValidChapter = result[result.length - 1];
                    }

                    const priorityActionType = this.getActionTypePrioritized([segment.actionType, latestChapter?.actionType]);

                    // Split the latest chapter if smaller
                    result.push({
                        segment: [segment.segment[0], segment.segment[1]],
                        originalDuration: segmentDuration,
                        actionType: priorityActionType
                    });
                    if (latestValidChapter?.segment[1] > segment.segment[1]) {
                        result.push({
                            segment: [segment.segment[1], latestValidChapter.segment[1]],
                            originalDuration: latestValidChapter.originalDuration,
                            actionType: latestValidChapter.actionType
                        });
                    }

                    chaptersToAddBack.reverse();
                    let lastChapterChecked: number[] = segment.segment;
                    for (const chapter of chaptersToAddBack) {
                        if (chapter.segment[0] < lastChapterChecked[1]) {
                            chapter.segment[0] = lastChapterChecked[1];
                        }

                        lastChapterChecked = chapter.segment;
                    }
                    result.push(...chaptersToAddBack);
                    if (latestValidChapter) latestValidChapter.segment[1] = segment.segment[0];
                } else {
                    // Start at end of old one otherwise
                    result.push({
                        segment: [latestChapter.segment[1], segment.segment[1]],
                        originalDuration: segmentDuration,
                        actionType: segment.actionType
                    });
                }
            } else {
                // Add empty buffer before segment if needed
                const lastTime = latestChapter?.segment[1] || 0;
                if (segment.segment[0] > lastTime) {
                    result.push({
                        segment: [lastTime, segment.segment[0]],
                        originalDuration: 0,
                        actionType: null
                    });
                }

                // Normal case
                const endTime = Math.min(segment.segment[1], this.videoDuration);
                result.push({
                    segment: [segment.segment[0], endTime],
                    originalDuration: endTime - segment.segment[0],
                    actionType: segment.actionType
                });
            }

            // Add empty buffer after segment if needed
            if (index === segments.length - 1) {
                const nextSegment = segments[index + 1];
                const nextTime = nextSegment ? nextSegment.segment[0] : this.videoDuration;
                const lastTime = result[result.length - 1]?.segment[1] || segment.segment[1];
                if (this.intervalToDecimal(lastTime, nextTime) > MIN_CHAPTER_SIZE) {
                    result.push({
                        segment: [lastTime, nextTime],
                        originalDuration: 0,
                        actionType: null
                    });
                }
            }
        });

        return result;
    }

    private getActionTypePrioritized(actionTypes: ActionType[]): ActionType {
        if (actionTypes.includes(ActionType.Skip)) {
            return ActionType.Skip;
        } else if (actionTypes.includes(ActionType.Mute)) {
            return ActionType.Mute;
        } else {
            return actionTypes.find(a => a) ?? actionTypes[0];
        }
    }

    private setupChapterSection(section: HTMLElement, startTime: number, endTime: number, addMargin: boolean): void {
        const sizePercent = this.intervalToPercentage(startTime, endTime);
        if (addMargin) {
            section.style.marginRight = `${this.chapterMargin}px`;
            section.style.width = `calc(${sizePercent} - ${this.chapterMargin}px)`;
        } else {
            section.style.marginRight = "0";
            section.style.width = sizePercent;
        }

        section.setAttribute("decimal-width", String(this.intervalToDecimal(startTime, endTime)));
    }

    private firstTimeSetupChapterSection(section: HTMLElement): void {
        section.addEventListener("mouseenter", () => {
            this.hoveredSection?.classList.remove("ytp-exp-chapter-hover-effect");
            section.classList.add("ytp-exp-chapter-hover-effect");
            this.hoveredSection = section;
        });
    }

    private createChapterMutationObservers(): void {
        if (this.testMode || !this.progressBar || !this.originalChapterBar) return; // Bypass in test mode or if elements missing

        const attributeObserver = new MutationObserver((mutations) => {
            if (this.testMode) return; // Don't run mutation logic in tests
            const changes: Record<string, HTMLElement> = {};
            for (const mutation of mutations) {
                const currentElement = mutation.target as HTMLElement;
                if (mutation.type === "attributes"
                    && currentElement.parentElement?.classList.contains("ytp-progress-list")) {
                    changes[currentElement.classList[0]] = mutation.target as HTMLElement;
                }
            }

            this.updateChapterMutation(changes, this.progressBar);
        });

        attributeObserver.observe(this.originalChapterBar, {
            subtree: true,
            attributes: true,
            attributeFilter: ["style", "class"]
        });

        const childListObserver = new MutationObserver((mutations) => {
            const changes: Record<string, HTMLElement> = {};
            for (const mutation of mutations) {
                if (mutation.type === "childList") {
                    this.update();
                    break;
                }
            }

            this.updateChapterMutation(changes, this.progressBar);
        });

        // Only direct children, no subtree
        childListObserver.observe(this.originalChapterBar, {
            childList: true
        });

        addCleanupListener(() => {
            attributeObserver.disconnect();
            childListObserver.disconnect();
        });
    }

    private updateChapterAllMutation(originalChapterBar: HTMLElement, progressBar: HTMLElement, firstUpdate = false): void {
        const elements = originalChapterBar.querySelectorAll(".ytp-progress-list > *");
        const changes: Record<string, HTMLElement> = {};
        for (const element of elements) {
            changes[element.classList[0]] = element as HTMLElement;
        }

        this.updateChapterMutation(changes, progressBar, firstUpdate);
    }

    private updateChapterMutation(changes: Record<string, HTMLElement>, progressBar: HTMLElement, firstUpdate = false): void {
        // Go through each newly generated chapter bar and update the width based on changes array
        if (this.customChaptersBar) {
            // Width reached so far in decimal percent
            let cursor = 0;

            const sections = this.customChaptersBar.querySelectorAll(".ytp-chapter-hover-container") as NodeListOf<HTMLElement>;
            for (let i = 0; i < sections.length; i++) {
                const section = sections[i];

                const sectionWidthDecimal = parseFloat(section.getAttribute("decimal-width"));
                const sectionWidthDecimalNoMargin = sectionWidthDecimal - this.chapterMargin / progressBar.clientWidth;

                for (const className in changes) {
                    const selector = `.${className}`
                    const customChangedElement = section.querySelector(selector) as HTMLElement;
                    if (customChangedElement) {
                        const fullSectionWidth = i === sections.length - 1 ? sectionWidthDecimal : sectionWidthDecimalNoMargin;
                        const changedElement = changes[className];
                        const changedData = this.findLeftAndScale(selector, changedElement, progressBar);

                        const left = (changedData.left) / progressBar.clientWidth;
                        const calculatedLeft = Math.max(0, Math.min(1, (left - cursor) / fullSectionWidth));
                        if (!isNaN(left) && !isNaN(calculatedLeft)) {
                            customChangedElement.style.left = `${calculatedLeft * 100}%`;
                            customChangedElement.style.removeProperty("display");
                        }

                        if (changedData.scale !== null) {
                            const transformScale = (changedData.scale) / progressBar.clientWidth;

                            const scale = Math.max(0, Math.min(1 - calculatedLeft, (transformScale - cursor) / fullSectionWidth - calculatedLeft));
                            customChangedElement.style.transform =
                                `scaleX(${scale})`;
                            if (customChangedElement.style.backgroundSize) {
                                const backgroundSize = Math.max(changedData.scale / scale, fullSectionWidth * progressBar.clientWidth);
                                customChangedElement.style.backgroundSize = `${backgroundSize}px`;

                                if (changedData.scale < (cursor + fullSectionWidth) * progressBar.clientWidth) {
                                    customChangedElement.style.backgroundPosition = `-${backgroundSize - fullSectionWidth * progressBar.clientWidth}px`;
                                } else {
                                    // Passed this section
                                    customChangedElement.style.backgroundPosition = `-${cursor * progressBar.clientWidth}px`;
                                }
                            }

                            if (firstUpdate) {
                                customChangedElement.style.transition = "none";
                                setTimeout(() => customChangedElement.style.removeProperty("transition"), 50);
                            }
                        }

                        if (customChangedElement.className !== changedElement.className) {
                            customChangedElement.className = changedElement.className;
                        }
                    }
                }

                cursor += sectionWidthDecimal;
            }

            if (sections.length !== 0 && sections.length !== this.existingChapters?.length
                    && Date.now() - this.lastChapterUpdate > 3000) {
                this.lastChapterUpdate = Date.now();
                this.updateExistingChapters();
            }
        }
    }

    private findLeftAndScale(selector: string, currentElement: HTMLElement, progressBar: HTMLElement):
            { left: number; scale: number } {
        const sections = currentElement.parentElement.parentElement.parentElement.children;
        let currentWidth = 0;
        let lastWidth = 0;

        let left = 0;
        let leftPosition = 0;

        let scale = null;
        let scalePosition = 0;
        let scaleWidth = 0;
        let lastScalePosition = 0;

        for (let i = 0; i < sections.length; i++) {
            const section = sections[i] as HTMLElement;
            const checkElement = section.querySelector(selector) as HTMLElement;
            const currentSectionWidthNoMargin = this.getPartialChapterSectionStyle(section, "width") ?? progressBar.clientWidth;
            const currentSectionWidth = currentSectionWidthNoMargin
                + this.getPartialChapterSectionStyle(section, "marginRight");

            // First check for left
            const checkLeft = parseFloat(checkElement.style.left.replace("px", ""));
            if (checkLeft !== 0) {
                left = checkLeft;
                leftPosition = currentWidth;
            }

            // Then check for scale
            const transformMatch = checkElement.style.transform.match(/scaleX\(([0-9.]+?)\)/);
            if (transformMatch) {
                const transformScale = parseFloat(transformMatch[1]);
                const endPosition = transformScale + checkLeft / currentSectionWidthNoMargin;

                if (lastScalePosition > 0.99999 && endPosition === 0) {
                    // Last one was an end section that was fully filled
                    scalePosition = currentWidth - lastWidth;
                    break;
                }

                lastScalePosition = endPosition;

                scale = transformScale;
                scaleWidth = currentSectionWidthNoMargin;

                if ((i === sections.length - 1 || endPosition < 0.99999) && endPosition > 0) {
                    // reached the end of this section for sure
                    // if the scale is always zero, then it will go through all sections but still return 0

                    scalePosition = currentWidth;
                    if (checkLeft !== 0) {
                        scalePosition += left;
                    }
                    break;
                }
            }

            lastWidth = currentSectionWidth;
            currentWidth += lastWidth;
        }

        return {
            left: left + leftPosition,
            scale: scale !== null ? scale * scaleWidth + scalePosition : null
        };
    }

    private getPartialChapterSectionStyle(element: HTMLElement, param: string): number {
        const data = element.style[param];
        if (data?.includes("%")) {
            return this.customChaptersBar.clientWidth * (parseFloat(data.replace("%", "")) / 100);
        } else {
            return parseInt(element.style[param].match(/\d+/g)?.[0]) || 0;
        }
    }

    updateChapterText(segments: SponsorTime[], submittingSegments: SponsorTime[], currentTime: number): SponsorTime[] {
        if (!Config.config.showSegmentNameInChapterBar
                || Config.config.disableSkipping
                || ((!segments || segments.length <= 0) && submittingSegments?.length <= 0 
                    && (Config.config.showAutogeneratedChapters || !hasAutogeneratedChapters()))) {
            const chaptersContainer = this.getChaptersContainer();
            if (chaptersContainer) {
                chaptersContainer.querySelector(".sponsorChapterText")?.remove();
                const chapterTitle = chaptersContainer.querySelector(".ytp-chapter-title-content") as HTMLDivElement;
    
                chapterTitle.style.removeProperty("display");
                chaptersContainer.classList.remove("sponsorblock-chapter-visible");
            }

            return [];
        }

        segments ??= [];
        if (submittingSegments?.length > 0) segments = segments.concat(submittingSegments);
        const activeSegments = segments.filter((segment) => {
            return segment.hidden === SponsorHideType.Visible
                && segment.segment[0] <= currentTime && segment.segment[1] > currentTime
                && segment.category !== DEFAULT_CATEGORY;
        });

        this.setActiveSegments(activeSegments);
        return activeSegments;
    }

    /**
     * Adds the text to the chapters slot if not filled by default
     */
    private setActiveSegments(segments: SponsorTime[]): void {
        const chaptersContainer = this.getChaptersContainer();

        if (chaptersContainer) {
            if (segments.length > 0) {
                chaptersContainer.classList.add("sponsorblock-chapter-visible");

                const chosenSegment = segments.sort((a, b) => {
                    if (a.actionType === ActionType.Chapter && b.actionType !== ActionType.Chapter) {
                        return -1;
                    } else if (a.actionType !== ActionType.Chapter && b.actionType === ActionType.Chapter) {
                        return 1;
                    } else if (a.actionType === ActionType.Chapter && b.actionType === ActionType.Chapter
                                && a.source === SponsorSourceType.Server && b.source !== SponsorSourceType.Server) {
                        return -0.5;
                    } else if (a.actionType === ActionType.Chapter && b.actionType === ActionType.Chapter
                                && a.source !== SponsorSourceType.Server && b.source === SponsorSourceType.Server) {
                        return 0.5;
                    } else {
                        return (b.segment[0] - a.segment[0]) * 4;
                    }
                })[0];

                const chapterButton = this.getChapterButton(chaptersContainer);
                if (chapterButton) {
                    chapterButton.classList.remove("ytp-chapter-container-disabled");
                    chapterButton.disabled = false;
                }

                const chapterTitle = chaptersContainer.querySelector(".ytp-chapter-title-content") as HTMLDivElement;
                chapterTitle.style.display = "none";

                const chapterCustomText = (chapterTitle.parentElement.querySelector(".sponsorChapterText") || (() => {
                    const elem = document.createElement("div");
                    chapterTitle.parentElement.insertBefore(elem, chapterTitle);
                    elem.classList.add("sponsorChapterText");
                    if (document.location.host === "tv.youtube.com") {
                        elem.style.lineHeight = "initial";
                    }
                    return elem;
                })()) as HTMLDivElement;
                chapterCustomText.innerText = chosenSegment.description || shortCategoryName(chosenSegment.category);

                if (chosenSegment.actionType !== ActionType.Chapter) {
                    chapterTitle.classList.add("sponsorBlock-segment-title");
                } else {
                    chapterTitle.classList.remove("sponsorBlock-segment-title");
                }

                if (chosenSegment.source === SponsorSourceType.Server) {
                    const chapterVoteContainer = this.chapterVote.getContainer();
                    if (document.location.host === "tv.youtube.com") {
                        if (!chaptersContainer.contains(chapterVoteContainer)) {
                            const oldVoteContainers = document.querySelectorAll("#chapterVote");
                            if (oldVoteContainers.length > 0) {
                                oldVoteContainers.forEach((oldVoteContainer) => oldVoteContainer.remove());
                            }
                            chaptersContainer.appendChild(chapterVoteContainer);
                        }
                    } else if (!chapterButton.contains(chapterVoteContainer)) {
                        const oldVoteContainers = document.querySelectorAll("#chapterVote");
                        if (oldVoteContainers.length > 0) {
                            oldVoteContainers.forEach((oldVoteContainer) => oldVoteContainer.remove());
                        }

                        chapterButton.insertBefore(chapterVoteContainer, this.getChapterChevron());
                    }

                    this.chapterVote.setVisibility(true);
                    this.chapterVote.setSegment(chosenSegment);
                } else {
                    this.chapterVote.setVisibility(false);
                }
            } else if (!Config.config.showAutogeneratedChapters && hasAutogeneratedChapters()) {
                // Keep original hidden
                chaptersContainer.querySelector(".sponsorChapterText")?.remove();
                const chapterTitle = chaptersContainer.querySelector(".ytp-chapter-title-content") as HTMLDivElement;

                chapterTitle.style.display = "none";
                chaptersContainer.classList.remove("sponsorblock-chapter-visible");

                const titlePrefixDot = chaptersContainer.querySelector(".ytp-chapter-title-prefix") as HTMLElement;
                if (titlePrefixDot) titlePrefixDot.style.display = "none";
                
                this.chapterVote.setVisibility(false);
            } else {
                chaptersContainer.querySelector(".sponsorChapterText")?.remove();
                const chapterTitle = chaptersContainer.querySelector(".ytp-chapter-title-content") as HTMLDivElement;

                chapterTitle.style.removeProperty("display");
                chaptersContainer.classList.remove("sponsorblock-chapter-visible");
                
                this.chapterVote.setVisibility(false);
            }
        }
    }

    private getChaptersContainer(): HTMLElement {
        if (document.location.host === "tv.youtube.com") {
            if (!document.querySelector(".ytp-chapter-container")) {
                const dest = document.querySelector(".ypcs-control-buttons-left");
                if (!dest) return null;
                const sbChapterContainer = document.createElement("div");
                sbChapterContainer.className = "ytp-chapter-container";
                const sbChapterTitleContent = document.createElement("div");
                sbChapterTitleContent.className = "ytp-chapter-title-content";
                sbChapterContainer.appendChild(sbChapterTitleContent);
                dest.appendChild(sbChapterContainer);
            }
        }
        return document.querySelector(".ytp-chapter-container") as HTMLElement;
    }

    private getChapterButton(chaptersContainer: HTMLElement): HTMLButtonElement {
        return (chaptersContainer ?? this.getChaptersContainer())
            ?.querySelector("button.ytp-chapter-title") as HTMLButtonElement;
    }

    remove(): void {
        this.container.remove();

        if (this.categoryTooltip) {
            this.categoryTooltip.remove();
            this.categoryTooltip = undefined;
        }

        if (this.categoryTooltipContainer) {
            this.categoryTooltipContainer.classList.remove(TOOLTIP_VISIBLE_CLASS);
            this.categoryTooltipContainer = undefined;
        }
    }

    private chapterFilter(segment: PreviewBarSegment): boolean {
        return (Config.config.renderSegmentsAsChapters || segment.actionType === ActionType.Chapter)
                && segment.actionType !== ActionType.Poi
                && this.chapterGroupFilter(segment);
    }

    private chapterGroupFilter(segment: SegmentContainer): boolean {
        return segment.segment.length === 2 && this.intervalToDecimal(segment.segment[0], segment.segment[1]) > MIN_CHAPTER_SIZE;
    }

    intervalToPercentage(actualStartTime: number, actualEndTime: number) {
        return `${this.intervalToDecimal(actualStartTime, actualEndTime) * 100}%`;
    }

    intervalToDecimal(actualStartTime: number, actualEndTime: number): number {
        // modifyTimelineEnabled check is implicitly handled by timeToDecimal
        const virtualStartDecimal = this.timeToDecimal(actualStartTime);
        const virtualEndDecimal = this.timeToDecimal(actualEndTime);
        return virtualEndDecimal - virtualStartDecimal;
    }

    timeToPercentage(time: number): string {
        return `${this.timeToDecimal(time) * 100}%`
    }

    timeToRightPercentage(time: number): string {
        return `${(1 - this.timeToDecimal(time)) * 100}%`
    }

    timeToDecimal(time: number): number {
        return this.decimalTimeConverter(time, true);
    }

    decimalToTime(decimal: number): number {
        return this.decimalTimeConverter(decimal, false);
    }

    /**
     * Decimal to time or time to decimal.
     * This is the core conversion function.
     * @param value The value to convert (either a time in seconds or a decimal representation of progress).
     * @param isTime True if `value` is a time in seconds (convert time to decimal), false if `value` is a decimal (convert decimal to time).
     */
    decimalTimeConverter(value: number, isTime: boolean): number {
        const modifyTimelineEnabled = typeof Config !== 'undefined' && Config.config?.modifyTimelineAsIfSegmentsWerentThere;
        const durationToUse = modifyTimelineEnabled ? this.virtualVideoDuration : this.videoDuration;

        // Helper function to determine if a segment should be excluded from timeline length calculations
        // when the virtual timeline is active.
        const isTimelineCalculationSkippable = (segment: PreviewBarSegment): boolean => {
            if (!this.getCategorySkipOption) return false; 
            const skipOption = this.getCategorySkipOption(segment.category);
            // Only ActionType.Skip segments with AutoSkip option affect the virtual timeline's length.
            return segment.actionType === ActionType.Skip && skipOption === CategorySkipOption.AutoSkip;
        };

        // Path 1: Virtual timeline is OFF, AND native YouTube chapters are present and being used for mapping.
        // This logic attempts to map time/decimals based on the visual widths of YouTube's chapter bars,
        // which might not be perfectly linear with actual time durations.
        // This path is intentionally skipped if `modifyTimelineEnabled` is true.
        if (this.originalChapterBarBlocks?.length > 1 && 
            this.existingChapters.length === this.originalChapterBarBlocks?.length && 
            !modifyTimelineEnabled) {
            
            const totalPixels = this.originalChapterBar.parentElement.clientWidth;
            let accumulatedPixelOffset = 0; // Renamed for clarity
            let lastProcessedChapterIndex = -1; // Renamed for clarity
            for (let i = 0; i < this.originalChapterBarBlocks.length; i++) {
                const chapterElement = this.originalChapterBarBlocks[i];
                const widthPixels = parseFloat(chapterElement.style.width.replace("px", ""));
                const marginPixels = chapterElement.style.marginRight ? parseFloat(chapterElement.style.marginRight.replace("px", "")) : 0;
                const chapterVisualWidth = widthPixels + marginPixels;

                // If converting time to decimal: Check if the target time `value` is beyond the current chapter.
                // If converting decimal to time: Check if the target decimal `value` is beyond the current chapter's visual span.
                if ((isTime && value >= this.existingChapters[i].segment[1]) || 
                    (!isTime && value >= (accumulatedPixelOffset + chapterVisualWidth) / totalPixels)) {
                    accumulatedPixelOffset += chapterVisualWidth;
                    lastProcessedChapterIndex = i;
                } else {
                    break; // Target value falls within this chapter or before it.
                }
            }

            const targetChapterIndex = lastProcessedChapterIndex + 1;
            if (targetChapterIndex < this.existingChapters.length) {
                const targetChapter = this.existingChapters[targetChapterIndex];
                const targetChapterBlock = this.originalChapterBarBlocks[targetChapterIndex];
                const targetChapterBlockWidth = parseFloat(targetChapterBlock.style.width.replace("px", ""));
                const targetChapterDuration = targetChapter.segment[1] - targetChapter.segment[0];

                if (isTime) { // Time to Decimal conversion
                    // Calculate how far (percentage-wise) the `value` (time) is into the targetChapter.
                    const timeIntoChapter = value - targetChapter.segment[0];
                    const percentageInChapter = (targetChapterDuration > 0) ? (timeIntoChapter / targetChapterDuration) : 0;
                    // The decimal value is the sum of previous chapters' visual widths plus the proportional visual width into the current chapter.
                    const decimalOffsetInChapter = percentageInChapter * (targetChapterBlockWidth / totalPixels);
                    return Math.min(1, (accumulatedPixelOffset / totalPixels) + decimalOffsetInChapter);
                } else { // Decimal to Time conversion
                    // Calculate how far (time-wise) the `value` (decimal) is into the targetChapter's visual representation.
                    const decimalIntoChapterBlock = (value * totalPixels - accumulatedPixelOffset) / targetChapterBlockWidth;
                    const timeOffsetInChapter = decimalIntoChapterBlock * targetChapterDuration;
                    return Math.max(0, targetChapter.segment[0] + timeOffsetInChapter);
                }
            }
        }

        // Path 2: Virtual timeline is ON, or (Virtual timeline is OFF AND native chapters are NOT being used for mapping).
        // Handles virtual timeline calculations or standard linear calculations if virtual timeline is off.

        // Handle division by zero or invalid duration.
        if (durationToUse === 0) return 0;

        if (modifyTimelineEnabled) {
            // Path 2a: Virtual Timeline is ON.
            if (isTime) { 
                // Actual Time to Virtual Decimal conversion.
                // Iterate through all segments (sorted by start time) to find how much duration from "skippable" segments
                // occurs before the given `value` (actual time).
                const actualTimeToAccountFor = value;
                let totalSkippedDurationBeforeValue = 0;
                
                if (this.segments) { // Ensure segments exist
                    const sortedSegments = [...this.segments].sort((a, b) => a.segment[0] - b.segment[0]);
                    for (const segment of sortedSegments) {
                        if (segment.segment[0] >= actualTimeToAccountFor) break; // Processed all relevant segments
                        
                        if (isTimelineCalculationSkippable(segment)) {
                            const segmentStart = segment.segment[0];
                            const segmentEnd = segment.segment[1];
                            // Calculate overlap between [0, actualTimeToAccountFor) and [segmentStart, segmentEnd)
                            const overlapStart = Math.max(0, segmentStart);
                            const overlapEnd = Math.min(actualTimeToAccountFor, segmentEnd);
                            if (overlapEnd > overlapStart) {
                                totalSkippedDurationBeforeValue += (overlapEnd - overlapStart);
                            }
                        }
                    }
                }
                const virtualTime = value - totalSkippedDurationBeforeValue;
                return Math.min(1, Math.max(0, virtualTime / durationToUse));

            } else { 
                // Virtual Decimal to Actual Time conversion.
                // Iterate through segments, accumulating actual time and virtual time.
                // When accumulated virtual time reaches the target virtual time (derived from `value` decimal),
                // the corresponding accumulated actual time is the result.
                const targetVirtualTime = value * durationToUse;
                let currentActualTime = 0;
                let currentVirtualTime = 0;
                let lastActualTimeAnchor = 0; // Marks the end of the last processed segment or start of video.

                if (!this.segments || this.segments.length === 0) {
                    return Math.max(0, Math.min(this.videoDuration, targetVirtualTime)); // Linear mapping if no segments
                }

                const sortedSegments = [...this.segments].sort((a, b) => a.segment[0] - b.segment[0]);

                for (const segment of sortedSegments) {
                    const actualSegmentStart = segment.segment[0];
                    const actualSegmentEnd = segment.segment[1];
                    
                    // Account for the gap between the last segment and this one (non-skippable content).
                    const gapDuration = actualSegmentStart - lastActualTimeAnchor;
                    if (gapDuration > 0) {
                        const virtualTimeInGap = gapDuration; // Gaps contribute 1:1 to virtual time.
                        if (currentVirtualTime + virtualTimeInGap >= targetVirtualTime) {
                            // Target falls within this gap.
                            const timeNeededFromGap = targetVirtualTime - currentVirtualTime;
                            return lastActualTimeAnchor + timeNeededFromGap;
                        }
                        currentVirtualTime += virtualTimeInGap;
                        currentActualTime = actualSegmentStart; // currentActualTime jumps to start of segment
                    }

                    // Process the current segment.
                    if (isTimelineCalculationSkippable(segment)) {
                        // This segment is skipped; it contributes to actual time but not virtual time.
                        currentActualTime = actualSegmentEnd;
                    } else {
                        // This segment is NOT skipped; it contributes to both actual and virtual time.
                        const virtualSegmentDuration = actualSegmentEnd - actualSegmentStart;
                        if (currentVirtualTime + virtualSegmentDuration >= targetVirtualTime) {
                            // Target falls within this non-skippable segment.
                            const timeNeededFromSegment = targetVirtualTime - currentVirtualTime;
                            return actualSegmentStart + timeNeededFromSegment;
                        }
                        currentVirtualTime += virtualSegmentDuration;
                        currentActualTime = actualSegmentEnd;
                    }
                    lastActualTimeAnchor = actualSegmentEnd;
                }

                // If the targetVirtualTime is beyond all processed segments,
                // it means it falls in the non-skippable area after the last segment.
                if (targetVirtualTime > currentVirtualTime) {
                    return currentActualTime + (targetVirtualTime - currentVirtualTime);
                }
                return currentActualTime; // Should be end of last segment if targetVirtualTime matched exactly
            }
        } else {
            // Path 2b: Virtual Timeline is OFF, and native chapters are NOT being used (or not present).
            // Standard linear conversion.
            if (isTime) { // Time to Decimal
                return (durationToUse > 0) ? Math.min(1, value / durationToUse) : 0;
            } else { // Decimal to Time
                return Math.max(0, value * durationToUse);
            }
        }
    }

    /*
    * Approximate size on preview bar for smallest element (due to &nbsp)
    */
    getMinimumSize(showLarger = false): number {
        return this.videoDuration * (showLarger ? 0.006 : 0.003);
    }

    // Name parameter used for cache
    private getSmallestSegment(timeInSeconds: number, segments: PreviewBarSegment[], name?: string): PreviewBarSegment | null {
        const proposedIndex = name ? this.lastSmallestSegment[name]?.index : null;
        const startSearchIndex = proposedIndex && segments[proposedIndex] === this.lastSmallestSegment[name].segment ? proposedIndex : 0;
        const direction = startSearchIndex > 0 && timeInSeconds < this.lastSmallestSegment[name].segment.segment[0] ? -1 : 1;

        let segment: PreviewBarSegment | null = null;
        let index = -1;
        let currentSegmentLength = Infinity;

        for (let i = startSearchIndex; i < segments.length && i >= 0; i += direction) {
            const seg = segments[i];
            const segmentLength = seg.segment[1] - seg.segment[0];
            const minSize = this.getMinimumSize(seg.showLarger);

            const startTime = segmentLength !== 0 ? seg.segment[0] : Math.floor(seg.segment[0]);
            const endTime = segmentLength > minSize ? seg.segment[1] : Math.ceil(seg.segment[0] + minSize);
            if (startTime <= timeInSeconds && endTime >= timeInSeconds) {
                if (segmentLength < currentSegmentLength) {
                    currentSegmentLength = segmentLength;
                    segment = seg;
                    index = i;
                }
            }

            if (direction === 1 && seg.segment[0] > timeInSeconds) {
                break;
            }
        }

        if (segment) {
            this.lastSmallestSegment[name] = {
                index: index,
                segment: segment
            };
        }

        return segment;
    }

    private getChapterChevron(): HTMLElement {
        return document.querySelector(".ytp-chapter-title-chevron");
    }
}

export default PreviewBar;
